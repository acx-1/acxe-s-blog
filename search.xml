<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数海钩沉]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%95%B0%E6%B5%B7%E5%8B%BE%E6%B2%89%2F</url>
    <content type="text"><![CDATA[本笔记的主要内容是关于学习中可能用到的数学知识。之所以叫《数海钩沉》是为了致敬研一上过的一门关于逻辑学的课程的老师，在课上老师提起了一段关于数海钩沉的往事。数海钩沉，从词义上看便能看出写此笔记的本意，数学是现代科学的基础，为了做研究我们时时在这之间沉浮。在沉浮之间，愿各位都能在各自的领域中有所成就。kappa系数混淆矩阵简介&emsp;&emsp;混淆矩阵，也称误差矩阵，Confusion Matrix。是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。&emsp;&emsp;混淆矩阵的每一列代表了预测类别，每一列的总数表示预测为该类别的数据的数目；每一行代表了数据的真实归属类别，每一行的数据总数表示该类别的数据实例的数目。每一列中的数值表示真实数据被预测为该类的数目：如下图，第一行第一列中的43表示有43个实际归属第一类的实例被预测为第一类，同理，第一行第二列的2表示有2个实际归属为第二类的实例被错误预测为第一类。预测类1类2类3实类14320类25451际类32349&emsp;&emsp;在人工智能中，混淆矩阵（confusion matrix）是可视化工具，特别用于监督学习，在无监督学习一般叫做匹配矩阵。在图像精度评价中，主要用于比较分类结果和实际测得值，可以把分类结果的精度显示在一个混淆矩阵里面。混淆矩阵是通过将每个实测像元的位置和分类与分类图像中的相应位置和分类相比较计算的。kappa系数&emsp;&emsp;Kappa系数用于一致性检验，也可以用于衡量分类精度，但kappa系数的计算是基于混淆矩阵的。&emsp;&emsp;kappa系数是一种衡量分类精度的指标。它是通过把所有地表真实分类中的像元总数（N）乘以混淆矩阵对角线（Xkk）的和，再减去某一类地表真实像元总数与该类中被分类像元总数之积对所有类别求和的结果，再除以总像元数的平方减去某一类地表真实像元总数与该类中被分类像元总数之积对所有类别求和的结果所得到的.计算公式如下：k = \frac{p_o - p_e}{1-p_e}其中，$p_0$ 是每一类正确分类的样本数量之和除以总样本数，也就是总体分类精度 。$p_e$为每一类预测分类数和实际分类数的乘积之和除以预测样本数的平方。&emsp;&emsp;以上面的混淆矩阵为例：p_0=\frac{43+45+49}{150}=0.9133, p_e=\frac{50\times45+50\times51+50\times54}{150\times150}=0.3333,因此，$k=\frac{0.9133-0.3333}{1-0.3333}=0.8699$结果判定&emsp;&emsp;kappa计算结果为-1~1，但通常kappa是落在 0~1 间，可分为五组来表示不同级别的一致性：0.0~0.20极低的一致性(slight)、0.21~0.40一般的一致性(fair)、0.41~0.60 中等的一致性(moderate)、0.61~0.80 高度的一致性(substantial)和0.81~1几乎完全一致(almost perfect)。To be continue…]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用python进行数据分析》学习笔记]]></title>
    <url>%2F2018%2F10%2F26%2F%E3%80%8A%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本篇文章主要内容来源于《利用python进行数据分析》第二版,主要是对学习资料的整理与补充，若是有疑问，欢迎指出~引入&emsp;&emsp;本篇文章来源于Wes Mckinney 的《Python for Data Analysis.2nd edition》,我看的是SeanCheney对该书的中文翻译本，链接在开头已给出。&emsp;&emsp;目前可提供的链接如下：相关电子书下载链接GitHub链接GitBook链接本书代码链接&emsp;&emsp;第二版和第一版的不同之处在于：包括Python教程内的所有代码升级为Python 3.6（第1版使用的是Python 2.7）更新了Anaconda和其它包的Python安装方法更新了Pandas为2017最新版新增了一章，关于更高级的Pandas工具，外加一些tips简要介绍了使用StatsModels和scikit-learnpython的一些特点python的优点如下:作为一种胶水语言&emsp;&emsp;Python成为成功的科学计算工具的部分原因是，它能够轻松地集成C、C++以及Fortran代码。大部分现代计算环境都利用了一些Fortran和C库来实现线性代数、优选、积分、快速傅里叶变换以及其他诸如此类的算法。许多企业和国家实验室也利用Python来“粘合”那些已经用了多年的遗留软件系统。拥有丰富的库资源&emsp;&emsp;在数据分析、交互式计算以及数据可视化方面，Python将不可避免地与其他开源和商业的领域特定编程语言/工具进行对比，如R、MATLAB、SAS、Stata等。近年来，由于Python的库（例如pandas和scikit-learn）不断改良，使其成为数据分析任务的一个优选方案。结合其在通用编程方面的强大实力，我们完全可以只使用Python这一种语言构建以数据为中心的应用。python的缺点如下：运行速度比编译型语言（java,c等）慢&emsp;&emsp;由于Python是一种解释型编程语言，因此大部分Python代码都要比用编译型语言（比如Java和C）编写的代码运行慢得多。由于程序员的时间通常都比CPU时间值钱，因此许多人也愿意对此做一些取舍。但是，在那些延迟要求非常小或高资源利用率的应用中（例如高频交易系统），耗费时间使用诸如C++这样更低级、更低生产率的语言进行编程也是值得的。对高并发、多线程的应用程序支持较差&emsp;&emsp;对于高并发、多线程的应用程序而言（尤其是拥有许多计算密集型线程的应用程序），Python并不是一种理想的编程语言。这是因为Python有一个叫做全局解释器锁（Global Interpreter Lock，GIL）的组件，这是一种防止解释器同时执行多条Python字节码指令的机制。虽然很多大数据处理应用程序为了能在较短的时间内完成数据集的处理工作都需要运行在计算机集群上，但是仍然有一些情况需要用单进程多线程系统来解决。&emsp;&emsp;这并不是说Python不能执行真正的多线程并行代码。例如，Python的C插件使用原生的C或C++的多线程，可以并行运行而不被GIL影响，只要它们不频繁地与Python对象交互。重要的python库库名简介功能NumPy引入惯例：import numpy as npNumerical Python的简称，是Python科学计算的基础包①快速高效的多维数组对象ndarray；②用于对数组执行元素级计算以及直接对数组执行数学运算的函数；③用于读写硬盘上基于数组的数据集的工具；④线性代数运算、傅里叶变换，以及随机数生成;⑤成熟的C API， 用于Python插件和原生C、C++、Fortran代码访问NumPy的数据结构和计算工具。pandas引入惯例：import pandas as pd兼具NumPy高性能的数组计算功能以及电子表格和关系型数据库（如SQL）灵活的数据处理能力。①有标签轴的数据结构，支持自动或清晰的数据对齐。这可以防止由于数据不对齐，或处理来源不同的索引不同的数据，所造成的错误；②集成时间序列功能；③相同的数据结构用于处理时间序列数据和非时间序列数据；④保存元数据的算术运算和压缩；⑤灵活处理缺失数据；⑥合并和其它流行数据库（例如基于SQL的数据库）的关系操作。matplolib引入惯例：import matplotlib.pyplot as plt是最流行的用于绘制图表和其它二维数据可视化的Python库。直接调用库即可绘图，很方便scipy是一组专门解决科学计算中各种标准问题域的包的集合。主要包括下面这些包：①scipy.integrate：数值积分例程和微分方程求解器；②scipy.linalg：扩展了由numpy.linalg提供的线性代数例程和矩阵分解功能；③scipy.optimize：函数优化器（最小化器）以及根查找算法；④scipy.signal：信号处理工具；⑤scipy.sparse：稀疏矩阵和稀疏线性系统求解器；⑥scipy.special：SPECFUN（这是一个实现了许多常用数学函数（如伽玛函数）的Fortran库）的包装器；⑦scipy.stats：标准连续和离散概率分布（如密度函数、采样器、连续分布函数等）、各种统计检验方法，以及更好的描述统计法scikit-learnPython的通用机器学习工具包，与pandas、statsmodels和IPython一起，scikit-learn对于Python成为高效数据科学编程语言起到了关键作用。它的子模块包括：①分类：SVM、近邻、随机森林、逻辑回归等等；②回归：Lasso、岭回归等等；③聚类：k-均值、谱聚类等等；④降维：PCA、特征选择、矩阵分解等等；⑤选型：网格搜索、交叉验证、度量；⑥预处理：特征提取、标准化。statsmodels引入惯例：import statsmodels as sm包含经典统计学和经济计量学的算法，是一个统计分析包。包括如下子模块：①回归模型：线性回归，广义线性模型，健壮线性模型，线性混合效应模型等等；②方差分析（ANOVA）；③时间序列分析：AR，ARMA，ARIMA，VAR和其它模型；④非参数方法：核密度估计，核回归；⑤统计模型结果可视化。python基础&emsp;&emsp;python基础的学习推荐廖雪峰的python教程(点击进入)。教程涵盖了python中常用的知识点，是作为快速入门教程的不错选择。里面的资料整理的很完整，在这一部分就不搬运了。&emsp;&emsp;ps：ipython很好用，基本包含了ide常用的功能，推荐！NumPy基础：数组及矢量运算概述&emsp;&emsp;NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。&emsp;&emsp;NumPy本身并没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于你更加高效地使用诸如pandas之类的工具。我们需要注意的特点之一就是它可以高效处理大数组的数据，体现于：数组占用的内存更少。&emsp;&emsp;因为NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。对数组的计算更方便。NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环NumPy的ndarray：一种多维数组对象&emsp;&emsp;ndarray，即N维数组对象，该对象是一个快速灵活的大数据集容器。这种数组对整块数据的数学运算的语法跟标量元素之间的运算一样。下面是其的一个简单的使用示例：123456789101112131415161718192021222324252627#引入numpyIn [12]: import numpy as np# 产生一些随机数In [13]: data = np.random.randn(2, 3)In [14]: dataOut[14]: array([[-0.2047, 0.4789, -0.5194], [-0.5557, 1.9658, 1.3934]]) #对数组进行一些简单的运算 In [15]: data * 10Out[15]: array([[ -2.0471, 4.7894, -5.1944], [ -5.5573, 19.6578, 13.9341]])In [16]: data + dataOut[16]: array([[-0.4094, 0.9579, -1.0389], [-1.1115, 3.9316, 2.7868]]) #查看数组的一些元属性In [17]: data.shapeOut[17]: (2, 3)In [18]: data.dtypeOut[18]: dtype('float64')ps：书中提到的‘数组’，‘numpy数组’，‘ndarray’基本上都是指ndarray对象创建ndarrayarray函数&emsp;&emsp;创建数组最简单的方法是使用array函数，它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的numpy数组。12345678910111213#使用array函数创建一维数组In [19]: data1 = [6, 7.5, 8, 0, 1]In [20]: arr1 = np.array(data1)In [21]: arr1Out[21]: array([ 6. , 7.5, 8. , 0. , 1. ])#使用array函数创建二维数组In [22]: data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]In [23]: arr2 = np.array(data2)In [24]: arr2Out[24]: array([[1, 2, 3, 4], [5, 6, 7, 8]])arange函数&emsp;&emsp;arange是Python内置函数range的数组版。123456789101112131415#使用arange函数创建一维数组In [20]: arr1 = np.arange(10)In [21]: arr1Out[21]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])#使用array函数创建有一定规律一维数组In [23]: arr2 = np.arange(2,6)In [24]: arr2Out[24]: array([2,3,4,5])In [25]: arr3 = np.arange(1,11,2)In [26]: arr3Out[26]: array([1,3,5,7,9])zeros函数,ones函数和empty函数&emsp;&emsp;除np.array之外，还有一些函数也可以新建数组。比如，zeros和ones分别可以创建指定长度或形状的全0或全1数组。empty可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可：123456789101112131415161718192021222324252627#zeros函数In [29]: np.zeros(10)Out[29]: array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])In [30]: np.zeros((3, 6))Out[30]: array([[ 0., 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0., 0.]])#empty函数(多数情况下，它返回的是一些未初始化的垃圾值)In [31]: np.empty((2, 3, 2))Out[31]: array([[[ 0., 0.], [ 0., 0.], [ 0., 0.]], [[ 0., 0.], [ 0., 0.], [ 0., 0.]]])#ones函数In [32]: np.ones(10)Out[32]: array([ 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])In [33]: np.zeros((3, 6))Out[33]: array([[ 1., 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1., 1.]])&emsp;&emsp;下面列出了一些数组创建函数。由于NumPy关注的是数值计算，因此，如果没有特别指定，数据类型基本都是float64（浮点数）。函数说明array将输入数据（列表、元组、数组或其他序列类型）转换为ndarray。要么推断出dtype，要么指定dtype。默认直接复制输入数据asarray将输入转换为ndarray，如果输入本身就是一个ndarray就不进行复制arange类似于内置的range,但返回的是一个ndarray，而不是列表ones,ones&#95;like根据指定的形状和dtype创建一个全1的数组。ones&#95;like以另一个数组为参数，并根据其形状和dtype创建一个全1数组zeros,zeros&#95;like类似于ones和ones&#95;like，只不过产生的是全0数组而已empty,empty&#95;like创建新数组，只分配内存空间但不填充任何值full,full&#95;like用fill value 中的所有值，根据指定的形状和dtype创建一个数组。eye,identity创建一个正方的N*N单位矩阵（对角线为1，其余为0）ndarray的数据类型&emsp;&emsp;dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息。多数情况下，它们直接映射到相应的机器表示，这使得“读写磁盘上的二进制数据流”以及“集成低级语言代码（如C、Fortran）”等工作变得更加简单。数值型dtype的命名方式相同：一个类型名（如float或int），后面跟一个用于表示各元素位长的数字。标准的双精度浮点值（即Python中的float对象）需要占用8字节（即64位）。因此，该类型在NumPy中就记作float64。下面列出了numpy所支持的所有数据类型。类型类型代码说明int8、uint8i1、u1有符号和无符号的8位（1个字节）整型int16、uint16i2、u2有符号和无符号的16位（2个字节）整型int32、uint32i4、u4有符号和无符号的32位（4个字节）整型int64、uint64i8、u8有符号和无符号的64位（8个字节）整型float16f2半精度浮点数float32f4或f标准的单精度浮点数。与C的float兼容float64f8或d标准的双精度浮点数。与C的double和python的float对象兼容float128f16或g扩展精度浮点数complex64,complex128,complex256c8、c16、c32分别用两个32位、64位或128位浮点数表示的复数bool?存储True和False值的布尔类型objectOPython对象类型stringS固定长度的字符串类型（每个字符一个字节）。例如，要创建一个长度为10的字符串，应使用S10unicodeU固定长度的unicode类型（字节数由平台决定）。跟字符串的定义方式一样（如U10）&emsp;&emsp;操作dtype,python提供了以下方法：12345678910111213141516171819#改变数组的dtypeIn [37]: arr = np.array([1, 2, 3, 4, 5])In [38]: arr.dtypeOut[38]: dtype('int64')In [39]: float_arr = arr.astype(np.float64)In [40]: float_arr.dtypeOut[40]: dtype('float64')#指定数组的dtype（将数字字符串转换为数字类型）In [44]: numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)In [45]: numeric_strings.astype(float)Out[45]: array([ 1.25, -9.6 , 42. ])#以字符串的形式指定dtypeIn [49]: empty_uint32 = np.empty(8, dtype='u4')In [50]: empty_uint32Out[50]: array([ 0, 1075314688, 0, 1075707904, 0, 1075838976, 0, 1072693248], dtype=uint32)ndarray数组的基本操作数组的运算与索引数组的基本运算&emsp;&emsp;数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy用户称其为矢量化（vectorization）。具体的运算如下:123456789101112131415161718192021222324252627282930313233343536373839#大小相等的数组之间的任何算术运算都会将运算应用到元素级In [51]: arr = np.array([[1., 2., 3.], [4., 5., 6.]])In [52]: arrOut[52]: array([[ 1., 2., 3.], [ 4., 5., 6.]])In [53]: arr * arrOut[53]: array([[ 1., 4., 9.], [ 16., 25., 36.]])In [54]: arr - arrOut[54]: array([[ 0., 0., 0.], [ 0., 0., 0.]])#数组与标量的算术运算会将标量值传播到各个元素：In [55]: 1 / arrOut[55]: array([[ 1. , 0.5 , 0.3333], [ 0.25 , 0.2 , 0.1667]])In [56]: arr ** 0.5Out[56]: array([[ 1. , 1.4142, 1.7321], [ 2. , 2.2361, 2.4495]]) #大小相同的数组之间的比较会生成布尔值数组：In [57]: arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])In [58]: arr2Out[58]: array([[ 0., 4., 1.], [ 7., 2., 12.]])In [59]: arr2 &gt; arrOut[59]:array([[False, True, False], [ True, False, True]], dtype=bool) #不同大小的数组之间的运算叫做广播（broadcasting），在这里暂时不深入探讨索引&emsp;&emsp;和python的list操作相似，numpy对ndarray提供了索引和切片的支持，并且拥有更强的可操作性。其提供的不仅仅是对一维数组对索引操作，对于二维、三维甚至是多维都适用。总的来说，可以分为批量的索引（切片）和离散的索引两个部分来说明：&emsp;&emsp;切片的基本操作可以从以下代码看出：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657##切片示例####对一维数组的操作#创建一个一维数组In [60]: arr = np.arange(10)In [61]: arrOut[61]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])#对数组进行切片In [62]: arr[5]Out[62]: 5In [63]: arr[5:8]Out[63]: array([5, 6, 7])#可以将切片赋值给另一个变量（类型也是一个数组），并进行操作In [64]: arr_slice = arr[5:8]In [65]: arr_slice = 12In [66]: arr_slice Out[66]: array([12, 12, 12])In [67]: arrOut[67]: array([ 0, 1, 2, 3, 4, 12, 12, 12, 8, 9])##对二维数组的操作#创建一个二维数组In [72]: arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])#对数组进行索引In [73]: arr2d[2]Out[73]: array([7, 8, 9])#对于子元素的索引，下面两种方式是等价的In [74]: arr2d[0][2]Out[74]: 3In [75]: arr2d[0, 2]Out[75]: 3#对数组进行切片In [76]: arr2d[:2] #对其中一维进行切片Out[76]: array([[1, 2, 3], [4, 5, 6]])In [77]: arr2d[:2, 1:] #对两个维度进行切片Out[77]: array([[2, 3], [5, 6]]) #对切片进行赋值也会扩散到整个选区In [78]: arr2d[:2, 1:] = 0In [79]: arr2dOut[79]: array([[1, 0, 0], [4, 0, 0], [7, 8, 9]])#########################################对于更高维数组的操作，和以上的操作类似#########################################&emsp;&emsp;对二维数组的切片选区，如下图所示：注：在上面所有这些选取数组子集的例子中，返回的数组都是视图。&emsp;&emsp;对数组进行离散的索引可以从以下代码看出：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110##离散的索引示例####使用布尔数组索引#产生一个布尔数组In [98]: names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])In [99]: names Out[99]: array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='&lt;U4') In [100]: names == 'Bob'Out[100]: array([ True, False, False, True, False, False, False], dtype=bool) #使用布尔数组索引In [101]: data = np.random.randn(7, 4)In [102]: data Out[101]: array([[ 0.0929, 0.2817, 0.769 , 1.2464], [ 1.0072, -1.2962, 0.275 , 0.2289], [ 1.3529, 0.8864, -2.0016, -0.3718], [ 1.669 , -0.4386, -0.5397, 0.477 ], [ 3.2489, -1.0212, -0.5771, 0.1241], [ 0.3026, 0.5238, 0.0009, 1.3438], [-0.7135, -0.8312, -2.3702, -1.8608]])In [102]: data[names == 'Bob'] #注：布尔型数组的长度必须跟被索引的轴长度一致。Out[102]: array([[ 0.0929, 0.2817, 0.769 , 1.2464], [ 1.669 , -0.4386, -0.5397, 0.477 ]])#布尔数组的一些常用操作In [103]: data[names == 'Bob'] #使用‘==’,‘&lt;’,'&gt;'等Out[103]: array([[ 0.0929, 0.2817, 0.769 , 1.2464], [ 1.669 , -0.4386, -0.5397, 0.477 ]])In [106]: names != 'Bob' #使用'!=' 、'~'Out[106]: array([False, True, True, False, True, True, True], dtype=bool) In [107]: data[~(names == 'Bob')] Out[107]: array([[ 1.0072, -1.2962, 0.275 , 0.2289], [ 1.3529, 0.8864, -2.0016, -0.3718], [ 3.2489, -1.0212, -0.5771, 0.1241], [ 0.3026, 0.5238, 0.0009, 1.3438], [-0.7135, -0.8312, -2.3702, -1.8608]])In [110]: mask = (names == 'Bob') | (names == 'Will') #使用逻辑运算符‘|、&amp;’等In [111]: mask Out[111]: array([ True, False, True, True, True, False, False], dtype=bool) In [112]: data[mask] Out[112]: array([[ 0.0929, 0.2817, 0.769 , 1.2464], [ 1.3529, 0.8864, -2.0016, -0.3718], [ 1.669 , -0.4386, -0.5397, 0.477 ], [ 3.2489, -1.0212, -0.5771, 0.1241]])##花式索引###花式索引（Fancy indexing）是一个NumPy术语，它指的是利用整数数组进行索引#定义一个数组In [117]: arr = np.empty((8, 4)) In [118]: for i in range(8): .....: arr[i] = i In [119]: arr Out[119]: array([[ 0., 0., 0., 0.], [ 1., 1., 1., 1.], [ 2., 2., 2., 2.], [ 3., 3., 3., 3.], [ 4., 4., 4., 4.], [ 5., 5., 5., 5.], [ 6., 6., 6., 6.], [ 7., 7., 7., 7.]]) #以特定顺序选取行子集In [120]: arr[[4, 3, 0, 6]] Out[120]: array([[ 4., 4., 4., 4.], [ 3., 3., 3., 3.], [ 0., 0., 0., 0.], [ 6., 6., 6., 6.]])In [121]: arr[[-3, -5, -7]] #使用负数索引将会从末尾开始选取行Out[121]: array([[ 5., 5., 5., 5.], [ 3., 3., 3., 3.], [ 1., 1., 1., 1.]])#一次传入多个索引数组时，取对应列的单个元素In [123]: arr Out[123]: array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31]]) In [124]: arr[[1, 5, 7, 2], [0, 3, 1, 2]] Out[124]: array([ 4, 23, 29, 10])#######################################################注：花式索引跟切片不一样，它总是将数据复制到新数组中。#######################################################利用数组进行数据处理数组转置和轴对换&emsp;&emsp;对数组元素位置的操作，最基本的就是重塑函数reshape。1234567#使用reshape函数重塑数组In [126]: arr = np.arange(15).reshape((3, 5)) In [127]: arrOut[127]: array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]])&emsp;&emsp;然后就是数组转置和轴对换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849##数组转置的使用In [126]: arr = np.arange(15).reshape((3, 5)) In [127]: arr Out[127]: array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14]]) In [128]: arr.T Out[128]: array([[ 0, 5, 10], [ 1, 6, 11], [ 2, 7, 12], [ 3, 8, 13], [ 4, 9, 14]]) ##轴对换的使用#transpose函数#这里，第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。In [132]: arr = np.arange(16).reshape((2, 2, 4)) In [133]: arr Out[133]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7]], [[ 8, 9, 10, 11], [12, 13, 14, 15]]]) In [134]: arr.transpose((1, 0, 2)) Out[134]: array([[[ 0, 1, 2, 3], [ 8, 9, 10, 11]], [[ 4, 5, 6, 7], [12, 13, 14, 15]]])#swapaxes函数(交换两个轴)In [135]: arr Out[135]: array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7]], [[ 8, 9, 10, 11], [12, 13, 14, 15]]]) In [136]: arr.swapaxes(1, 2) Out[136]: array([[[ 0, 4], [ 1, 5], [ 2, 6], [ 3, 7]], [[ 8, 12], [ 9, 13], [10, 14], [11, 15]]])注：在这里，返回的都是源数据的视图（不会进行任何复制操作）快速的元素级数组函数：通用函数&emsp;&emsp;通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。许多ufunc都是简单的元素级变体，如sqrt和exp：&emsp;&emsp;其使用方法如下：12pass数组文件的输入输出pass线性代数pass伪随机数生成pass示例：随机漫步pandas 入门pass数据加载、存储与文件格式&emsp;&emsp;数据分析的第一步是访问数据，这一章主要介绍pandas的数据输入与输出。输入输出通常可以划分为几个大类：读取文本文件和其他更高效的磁盘存储格式，加载数据库中的数据，利用WEB API操作网络资源。文本格式数据的读写&emsp;&emsp;pandas提供了一些将表格型数据读取为DataFrame对象的函数，下面是一些常用的函数：函数说明read_csv从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为逗号read_table从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为制表符（‘\t’）read_fwf读取定宽列格式数据（也就是说，没有分隔符）read_clipboard读取剪贴板中的数据，可以看做read_table的剪贴板版，在将网页转换为表格时很有用read_excel从Excel XLS 或XLSX file 读取表格数据read_hdf读取pandas写的HDF5文件read_html读取HTML文档中的所有表格read_json读取JSON字符串中的数据read_msgpack二进制格式编码的pandas数据read_pickle读取Python pickle格式中存储的任意对象read_sas读取存储于SAS系统自定义存储格式的SAS数据集read_sql(使用SQLAlchemy)读取SQL查询结果为pandas的DataFrameread_stata读取Stata文件格式的数据集read_feather读取Feather二进制文件格式&amp;emsp&emsp;以上函数中可配置的参数有很多，大体可分为以下几类：索引：将一个或多个列当做返回的DataFrame处理，以及是否从文件、用户获取列名。类型推断和数据转换：包括用户定义值的转换、和自定义的缺失值标记列表等。日期解析：包括组合功能，比如将分散在多个列中的日期时间信息组合成结果中的单个列。迭代：支持对大文件进行逐块迭代。不规整数据问题：跳过一些行、页脚、注释或其他一些不重要的东西（比如由成千上万个逗号隔开的数值数据）。&amp;emsp&emsp;通过代码我们可以看到一些常用的用法。12大体上来讲，read_csv`read_table`函数的参数有：参数名说明path表示文件系统位置、URL、文件型对象的字符串逐块读取文本文件To be continue….]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery学习笔记]]></title>
    <url>%2F2018%2F09%2F10%2Fjquery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[jquery简介javascript的缺点代码比较麻烦，需要遍历，可能还需要嵌套找到对象麻烦，方法少，还长会有兼容性问题js注册事件，会被覆盖，addEventListenerjquery的第一个程序12345678910111213141516//1.引入文件&lt;script src="jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;script&gt;//2.写入口函数$(document).ready(function()&#123; //注册事件，把on去掉，是一个方法 $("#btn1").click(function()&#123; $("div").show(); &#125;); $("btn2").click(function()&#123; //隐式迭代，jquery会自动遍历，不需要我们遍历 $("div").text("我是内容"); &#125;);&#125;);&lt;/script&gt;什么是jquery？&emsp;&emsp;jquery就是一个轻量级的js库，它有丰富的api可供调用，学习jquery其实就是学习jquery里的api。jquery的版本问题1.x,2.x,3.x版本的区别&emsp;&emsp;1.x版本和2.x版本是同步发布的，但1.x版本支持ie678,2.x不支持；且两个版本不再更新&emsp;&emsp;3.x不兼容ie678，且3.x版本还在更新；min版与非min版的区别&emsp;&emsp;非min版主要用于学习与开发，有注释，且可阅读性较强；min版是压缩版，没有注释，容量较小，用于生产环境。jquery的入口函数123456789//jquery入口函数的两种写法//第一种写法$(document).ready(function()&#123;...&#125;);//第二种写法$(function()&#123;...&#125;);注意：jquery的入口函数要比js的入口函数执行的早一些jquery的入口函数会等待页面加载完成才执行，但是不会等待图片的加载js的入口函数会等待页面加载完成，并且等待图片加载完成才开始执行DOM对象(js对象)与jq对象什么是DOM对象（js对象）：使用js的方式获取到的元素就是js对象（dom对象）var cloth = document.getElementById(&quot;cloth&quot;); cloth.style.backgroundColor = &quot;pink&quot;;什么是jq对象：使用jq的方式获取到的元素就是jq对象var $li=$(&quot;li&quot;); $li.text(&quot;I Change the context.&quot;);jq对象与js对象的区别：js对象不能调用jq对象的方法jq对象与js对象的联系&emsp;&emsp;jq对象其实就是js对象的一个集合，伪数组，里面存放了一大堆js对象（宏观上）DOM对象与jq对象的转换。&emsp;&emsp;dom2jq:var cloth = document.getElementById(&quot;cloth&quot;); $(cloth).text(&quot;hehe&quot;);&emsp;&emsp;jq2dom:$(&quot;li&quot;)[0].innerText = &quot;hehe&quot;;或$(&quot;li&quot;).get(0).innerText = &quot;haha&quot;;注意：$其实就是一个函数，以后用时记得跟小括号，参数不同，功能就不同，有3种用法：（另: $==jQuery）参数是一个function，入口函数参数是dom对象，把dom对象转换成jquery对象参数是一个字符串，根据前缀找对应类别的对象选择器&emsp;jquery选择器是jquery提供的一组方法，用来获取页面中的元素。其返回的是jqueryduixiang，且兼容了css1到css3的所有选择器（css怎么写，我们就可以怎么写），并且jquery还添加了很多更加复杂的选择器。基本选择器与层级选择器12345$("#id").css("backgroundColor","red");//id选择器的样式设置$("#id,.green").css("backgroundColor","red");//并集，id为id或class为green的标签都会被设置$("li.green").css("backgroundColor","red");//交集，li标签下的green标签样式会被设置$("li&gt;p").css("backgroundColor","red");//子代选择器，li标签下的子代中的p标签样式会被设置$("li p").css("backgroundColor","red");//后代选择器，li标签下的所有p标签样式会被设置mouseenter与mouseover&emsp;&emsp;mouseenter是jquery提供的鼠标事件，触发率比mouseover精准，建议使用；其中mouseleaving与mouseenter搭配，mouseover与mouseout搭配过滤选择器：这类选择器都带冒号，（如 li:first 为第一个li标签）筛选选择器&emsp;&emsp;与过滤选择器类似，但是用法不同，筛选选择器主要是方法名称用法描述children(selector)$(“ul”).children(“li”)相当于$(“ul&gt;li”),子类选 择器find(selector)同上相当于后代选择器siblings(selector)同上查找兄弟节点，但不包括自己parent()同上查找父母节点eq(index)同上查找下标为index的节点next()同上查找下一个兄弟节点prev()同上查找上一个兄弟节点index()同上返回当前兄弟节点中的下标操作方法css操作123456789//修改单个样式$("ul").css("backgroundColor","red");//修改多个样式$("li").css(&#123; backgroundColor:"red", fontSize:"12px"&#125;);//取得样式$("li").css("fontSize");class操作12345678//添加类$("ul").addClass(name);//移除类$("ul").removeClass(name);//判断类$("ul").hasClass(name);//切换$("ul").toggleClass(name);操作属性12345678910////attr//设置单个属性$("ul").attr("xx","yy");//设置多个属性$("ul").attr(&#123;xx:yy,aa:bb&#125;);//移除属性$("ul").removeAttr(name);////prop:对于布尔类型的属性，disabled,selected,checked,只能用prop$("ul").prop("selected",true);动画1234567891011////////使用方法均为如：$("ul").xxx([time]);////三组基本动画show/hide:显示/隐藏slideDowm/slideUp/slideToggle:滑动显示/隐藏/切换fadeIn/fadeOut/fadeToggle:渐变显示/隐藏/切换////自定义动画animate(prop[,speed][,swing/linear][,callback]);////停止动画stop()：停止动画，在使用某一动画前调用，可防止动画队列过多操作节点123456789101112131415////创建节点$(&quot;&lt;span&gt;&lt;/span&gt;&quot;); ////添加节点A.append(B);//将B节点移到A节点内最后的位置B.appendTo(A);//将B节点移到A节点内最后的位置A.prepend(B);//将B节点移到A节点内第一个位置B.prependTo(A);//将B节点移到A节点内第一个位置A.after(B);//将A节点移到B节点后A.before(B);//将A节点移到B节点前////清空节点A.empty();//清空节点内内容////删除节点A.remove();//删除当前节点////克隆节点A.clone();//复制当前节点特殊的属性操作123456789101112131415161718192021222324/////无参数时获取属性，有参时设置属性val(); //操作value值text()/html() //操作innertext，innerHTML属性width()/height() //操作width/height属性scrollTop()/scrollLeft() //操作滚动条事件offset()/position() //操作对于document/父元素的位置属性////注册事件 on off//当参数为两个时，为当前对象注册事件A.on(&quot;click&quot;,function()&#123;&#125;);//当参数为三个时，为当前元素的子元素注册事件A.on(&quot;click&quot;,&quot;p&quot;,function()&#123;&#125;);//在参数为3个，且第二个为数据时，通过事件e传值A.on(&quot;click&quot;,data,function(e)&#123;xxx(e.data);&#125;);A.off(&quot;click&quot;); //阻止所有 事件A.trigger(&quot;click&quot;); //触发A的click事件e.stopPropagation(); //禁止冒泡e.preventDefault(); //事件解绑//在on（）的function事件中使用return false；达到阻止冒泡和默认的效果////补充end(); //返回链式编程中的前一对象each(function(index,element)&#123;&#125;); //循环遍历$.noConflict(); //释放$的占用jquery插件&emsp;&emsp;jquery插件是对jquery进行功能上的优化的一项技术。使用方法为在引入jquery文件后，再引入jquery插件。jquery.color.js&emsp;&emsp;提供了一些关于颜色的功能，如颜色动态渐变等jquery.lazyload.js&emsp;&emsp;可以为网站提供懒加载功能，即显示时才加载。用法如下12345678910&lt;img class="lazy" data-original="01.gif" /&gt;//jsp文件最后面&lt;script src="jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;script src="jquery.lazyload.js" &gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $(".lazy").lazyload(); &#125;);&lt;/script&gt;ajax的使用&emsp;&emsp;ajax:异步请求，浏览器地址栏不变，进行局部刷新jquery的ajax&emsp;&emsp;ajax常用的请求有六种，可分为三层第一层：&emsp;&emsp;$.ajax(uel[,settings]);//最底层ajax请求，编写最复杂，完成功能最全第二层：&emsp;&emsp;$.load(url[,data][,callback]);$.get(url[,data][,fn][,type]);$.post(url[,data][,fn][,type]);//开发中常用的3个第三层：&emsp;&emsp;$.getJSON(url[,data][,fn]);$.getScript(url[,callback]);//高级开发12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576////getJson()与getScript()方法 $.getJSON() 可以完成js“跨域”请求 域名：域名+端口+项目，js默认不能跨域请求。 $.getScript() 动态加载js文件。之前使用&lt;script src=&quot;&quot;&gt;加载页面时，一并加载js文件////load()方法的使用 //0.2 请求参数，采用json var params = &#123;&quot;username&quot;:&quot;杰克&quot;, &quot;password&quot;:&quot;1234&quot;&#125;; /* 1 load()函数 ，必须使用jquery对象 * * 格式：load(url, [data], [callback]) * 参数1：url ，请求路径 * 参数2：data，请求参数 * 参数3：callback，回调函数 * * 如果没有请求参数，发送的GET请求 * * 如果有请求参数，发送的POST请求。请求没有中文乱码 * * 回调函数的参数 * 参数1：data，响应数据。load()永远获得字符串，如果需要使用，必须手动转换json对象。 */ $(this).load(url,params,function(data)&#123; //转换json对象 var jsonData = eval(&quot;(&quot;+data+&quot;)&quot;); alert(jsonData.message); &#125;);////get()和post()方法的使用 /* 2 $.get() 全局函数，发送get请求 * * 格式：jQuery.get(url, [data], [callback], [type]) * * 参数4：type ，返回内容格式，xml, html, script, json, text, _default。 * * GET请求不适合发送中文数据，存放请求的中文乱码。 * 必须手动解码 new String(username.getBytes(&quot;ISO-8859-1&quot;) ,&quot;UTF-8&quot;) * * 响应数据，如果使用 application/json;charset=UTF-8 ，jQuery自动将数据转换json对象。 * * 响应数据，如果使用 text/html;charset=UTF-8 ，回调函数获得字符串数据，需要手动转换。 * 使用“参数4”，设置&quot;json&quot;，jQuery将字符串 转换成 json对象 */ $.get(url,params,function(data)&#123; alert(data); &#125;,&quot;json&quot;); /* 3 $.post() 全局函数，与get方法相似发送post请求 * * 格式：jQuery.post(url, [data], [callback], [type]) */ $.post(url,params,function(data)&#123; alert(data); &#125;,&quot;json&quot;)； ////ajax()方法的使用 /* 4 $.ajax() 底层功能最强大的 * * 格式：jQuery.ajax([settings]) * 参数settings：设置所有的参数 * url:发送请求的地址 * data:发送到服务器的数据,请求参数 * type:请求方式 (&quot;POST&quot; 或 &quot;GET&quot;)， * success:成功的回调函数，success(data, textStatus, jqXHR) * error:请求失败时调用此函数 * dataType:预期服务器返回的数据类型 * &quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理。 * &quot;html&quot;: 返回纯文本 HTML 信息；包含的script标签会在插入dom时执行。 * &quot;script&quot;: 返回纯文本 JavaScript 代码。 * 不会自动缓存结果。除非设置了&quot;cache&quot;参数。 * 注意：在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载) * &quot;json&quot;: 返回 JSON 数据 。 * &quot;jsonp&quot;: JSONP 格式。使用 JSONP 形式调用函数时， * 如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 * &quot;text&quot;: 返回纯文本字符串 */ $.ajax(&#123; &quot;url&quot;:url, &quot;data&quot;:params, &quot;type&quot;:&quot;POST&quot;, &quot;success&quot;:function(data)&#123; alert(data); &#125;, &quot;error&quot;:function()&#123; alert(&quot;服务器繁忙，请稍后重试&quot;); &#125;, &quot;dataType&quot;:&quot;json&quot; &#125;);]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习笔记]]></title>
    <url>%2F2018%2F08%2F27%2FSpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Tips:本笔记主要信息来自于传智播客2015年胡斌SpringMVC备课笔记。笔记内容为：学习资料 + 个人补充；如有内容或排版方面的错误，欢迎纠正~SpringMVC介绍为什么使用SpringMVC？&emsp;&emsp;很多应用程序的问题在于处理业务数据和显示业务数据的视图的对象之间存在紧密耦合。通常，更新业务对象的命令都是从视图本身发起的，使视图对任何业务对象更改都有高度敏感性。而且，当多个视图依赖于同一个业务对象时是没有灵活性的。&emsp;&emsp;Spring Web MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC也是要简化我们日常Web开发的。MVC设计模型&emsp;&emsp;MVC 是一种著名的设计模式，特别是在 Web 应用程序领域。模式全都是关于将包含业务数据的模块与显示模块的视图解耦的。这是怎样发生的？视图（例如，JSP 页面）怎样能够与其模型（例如，包含数据的 JavaBean）解耦？记得这句格言么？一个层次的重定向几乎可以解决计算机业中的所有问题。确实，在模型和视图之间引入重定向层可以解决问题。此重定向层是控制器。控制器将接收请求，执行更新模型的操作，然后通知视图关于模型更改的消息。依赖于模型的状态并且依赖于请求的控制器可以决定要显示哪个视图。图 1 演示了这种模式。SpringMVC的强大之处Spring MVC 实现了即用的 MVC 的核心概念。它为控制器和处理程序提供了大量与此模式相关的功能。并且当向 MVC 添加反转控制（Inversion of Control，IoC）时，它使应用程序高度解耦，提供了通过简单的配置更改即可动态更改组件的灵活性。Spring MVC 为您提供了完全控制应用程序的各个方面的力量。Spring 的 Web MVC 模块是围绕 DispatcherServlet 而设计的。DispatcherServlet 给处理程序分派请求，执行视图解析，并且处理语言环境和主题解析，此外还为上传文件提供支持。DispatcherServlet 通过使用处理程序映射来决定哪一个处理程序应当处理传入的请求。处理程序映射只是用于标识使用哪一个处理程序来处理特定 URL 模式的映射。处理程序是只有一种方法 ModelAndView handleRequest(request,response) 的控制器接口的实现。Spring 还有一些可用的高级处理程序实现；其中一个重要的高级处理程序实现是 SimpleFormController，它提供了将命令对象绑定到表单、对其执行验证等功能。在本系列教程(传智播客黑马程序员系列)的先前教程中使用了 DispatcherServlet 和简单的处理程序。在下一个部分中，将使用 SimpleFormController 并说明 Spring MVC 提供的各种即用功能。springMVC优势清晰的角色划分：前端控制器（DispatcherServlet）、请求到处理器映射（HandlerMapping）、处理器适配器（HandlerAdapter）、视图解析器（ViewResolver）、处理器或页面控制器（Controller）、验证器（ Validator）、命令对象（Command 请求参数绑定到的对象就叫命令对象）、表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要；由于命令对象就是一个POJO，无需继承框架特定API，可以使用命令对象直接作为业务对象；和Spring 其他框架无缝集成，是其它Web框架所不具备的；可适配，通过HandlerAdapter可以支持任意的类作为处理器；可定制性，HandlerMapping、ViewResolver等能够非常简单的定制；功能强大的数据验证、格式化、绑定机制；利用Spring提供的Mock对象能够非常简单的进行Web层单元测试；本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。强大的JSP标签库，使JSP编写更容易。………………还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配置支持等等。SpringMVC的运行原理架构图传统的MVC架构&emsp;&emsp;首先让我们了解下 MVC（Model-View-Controller）三元组的概念：Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或 JavaBean 组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据） 和 服务层（行为）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。领域模型，javaBean组件等价于 域模型层 + 业务逻辑层 + 持久层View(视图):负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。Controller(控制器):接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作，。从上图我们还看到，在标准的 MVC 中模型能主动推数据给视图进行更新（观察者设计模式，在模型上注册视图，当模型更新时自动更新视图），但在 Web 开发中模型是无法主动推给视图（无法主动更新用户界面），因为在 Web 开发是请求-响应模型。&emsp;&emsp;核心架构的具体流程步骤如下：首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；DispatcherServlet——&gt;HandlerMapping,HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略；DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。DispatcherServlet核心代码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//前端控制器分派方法 protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; int interceptorIndex = -1; try &#123; ModelAndView mv; boolean errorView = false; try &#123; //检查是否是请求是否是multipart（如文件上传），如果是将通过MultipartResolver解析 processedRequest = checkMultipart(request); //步骤2、请求到处理器（页面控制器）的映射，通过HandlerMapping进行映射 mappedHandler = getHandler(processedRequest, false); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; //步骤3、处理器适配，即将我们的处理器包装成相应的适配器（从而支持多种类型的处理器） HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // 304 Not Modified缓存支持 //此处省略具体代码 // 执行处理器相关的拦截器的预处理（HandlerInterceptor.preHandle） //此处省略具体代码 // 步骤4、由适配器执行处理器（调用处理器相应功能处理方法） mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); // Do we need view name translation? if (mv != null &amp;&amp; !mv.hasView()) &#123; mv.setViewName(getDefaultViewName(request)); &#125; // 执行处理器相关的拦截器的后处理（HandlerInterceptor.postHandle） //此处省略具体代码 &#125; catch (ModelAndViewDefiningException ex) &#123; logger.debug("ModelAndViewDefiningException encountered", ex); mv = ex.getModelAndView(); &#125; catch (Exception ex) &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(processedRequest, response, handler, ex); errorView = (mv != null); &#125; //步骤5 步骤6、解析视图并进行视图的渲染 //步骤5 由ViewResolver解析View（viewResolver.resolveViewName(viewName, locale)） //步骤6 视图在渲染时会把Model传入（view.render(mv.getModelInternal(), request, response);） if (mv != null &amp;&amp; !mv.wasCleared()) &#123; render(mv, processedRequest, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Null ModelAndView returned to DispatcherServlet with name '" + getServletName() + "': assuming HandlerAdapter completed request handling"); &#125; &#125; // 执行处理器相关的拦截器的完成后处理（HandlerInterceptor.afterCompletion） //此处省略具体代码 catch (Exception ex) &#123; // Trigger after-completion for thrown exception. triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex) throw ex; &#125; catch (Error err) &#123; ServletException ex = new NestedServletException("Handler processing failed", err); // Trigger after-completion for thrown exception. triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex); throw ex; &#125; finally &#123; // Clean up any resources used by a multipart request. if (processedRequest != request) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;SpringMVC的第一个程序创建一个javaweb工程包：cn.itcast.controller导入Spring的jar包配置DispatcherServlet核心分发器(web.xml)1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--我们经常使用的配置文件加载方式--&gt; &lt;!-- &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; --&gt;&lt;/servlet&gt;&lt;!-- 加载默认mvc配置文件：springname-servlet.xml ,必须放在WEB-INF下面--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;//或者使用默认拦截/&lt;/servlet-mapping&gt;说明：/和/*的区别？&emsp;&emsp;可以实现现在很流行的REST风格。很多互联网类型的应用很喜欢这种风格的URL。&emsp;&emsp;弊端：会导致静态文件（jpg,js,css）被拦截后不能正常显示。想实现REST风格，事情就是麻烦一些。后面有解决办法还算简单。&emsp;&emsp;拦截/*，这是一个错误的方式，请求可以走到Action中，但转到jsp时再次被拦截，不能访问到jsp。配置handlerMapping映射器123456789101112131415161718&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd "&gt; &lt;!-- 处理器映射器 --&gt; &lt;!-- 根据bean的name进行查找Handler 将action的url配置在bean的name中 --&gt; &lt;!-- 这是一个默认的映射处理器,即使不配置，那么也是默认就是这个 --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt;配置handlerAdapter适配器12//注意：这个适配器不是必须配置的，这是默认的、他在servlet容器已启动就被加载。&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt;编写一个Controller类123456789101112131415161718public class TestController implements Controller&#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; /** * 1.收集参数、验证参数 * 2.绑定参数到命令对象 * 3.将命令对象传入业务对象进行处理 * 4.选择视图 */ ModelAndView mv = new ModelAndView(); //添加模型数据，那么这个数据可以是任意的POJO对象。 mv.addObject("hello","hello world!!"); //设置逻辑视图名，视图解析器会根据该名字解析到具体的视图界面 mv.setViewName("/WEB-INF/jsps/hello.jsp"); return mv; &#125; &#125;配置自定义控制器12&lt;!-- 配置自定义controller ,使用beanName:name=”/hello.do”进行进行请求映射匹配--&gt;&lt;bean name="/hello.do" class="cn.itcast.test.TestController"&gt;&lt;/bean&gt;定义一个响应页面(hello.jsp)配置视图解析器1234567&lt;!-- 使用视图解析器解析逻辑视图，这样跟方便，易于扩展。--&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--逻辑视图前缀--&gt; &lt;property name="prefix" value="/WEB-INF/jsps/"&gt;&lt;/property&gt; &lt;!--逻辑视图后缀，匹配模式：前缀+逻辑视图+后缀，形成完整路径名--&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;程序执行流程1、 首先用户发送请求`http://localhost:9080/springmvc-01/hello``——&gt;web容器，web容器根据“/hello”路径映射到DispatcherServlet（url-pattern为/）进行处理；2、 DispatcherServlet——&gt;BeanNameUrlHandlerMapping进行请求到处理的映射，BeanNameUrlHandlerMapping将“/hello”路径直接映射到名字为“/hello”的Bean进行处理，即HelloWorldController，BeanNameUrlHandlerMapping将其包装为HandlerExecutionChain（只包括HelloWorldController处理器，没有拦截器)3、DispatcherServlet——&gt; SimpleControllerHandlerAdapter，SimpleControllerHandlerAdapter将HandlerExecutionChain中的处理器(HelloWorldController)适配为SimpleControllerHandlerAdapter；4、 SimpleControllerHandlerAdapter——&gt; HelloWorldController处理器功能处理方法的调用，SimpleControllerHandlerAdapter将会调用处理器的handleRequest方法进行功能处理，该处理方法返回一个ModelAndView给DispatcherServlet；5、 hello（ModelAndView的逻辑视图名）——&gt;InternalResourceViewResolver， InternalResourceViewResolver使用JstlView，具体视图页面在/WEB-INF/jsp/hello.jsp；6、 JstlView（/WEB-INF/jsp/hello.jsp）——&gt;渲染，将在处理器传入的模型数据(message=HelloWorld！)在视图中展示出来；7、 返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。到此HelloWorld就完成了，步骤是不是有点多？而且回忆下我们主要进行了如下配置：1、 前端控制器DispatcherServlet；2、 HandlerMapping3、 HandlerAdapter4、 ViewResolver5、 处理器/页面控制器6、 视图HandlerMappingBeanNameUrlHandlerMapping&emsp;&emsp;根据url请求去匹配bean的name属性url，从而获取Controller。HandlerMapping 将会把请求映射为 HandlerExecutionChain 对象（包含一个 Handler 处理器（页面控制器）对象、多个 HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略;配置案例：1234//默认映射器，即使不配置，默认就使用这个来映射请求。&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt;//映射器把请求映射到controller&lt;bean id="testController" name="/hello.do" class="cn.itcast.controller.TestController"&gt;&lt;/bean&gt;SimpleUrlHandlerMapping&emsp;&emsp; 根据浏览器url匹配简单url的key，key又Controller的id找到Controller1234567891011&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/hello1.do"&gt;testController&lt;/prop&gt; &lt;prop key="/a.do"&gt;testController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;//那么上面的这个映射配置：表示多个*.do文件可以访问多个Controller或者一个Controller。 //前提是：都必须依赖自定义的控制器bean&lt;bean id="testController" name="/hello.do" class="cn.itcast.controller.TestController"&gt;&lt;/bean&gt;ControllerClassNameHandlerMapping&emsp;&emsp; 根据类名（MyController）类名.do来访问,类名首字母小写12//这个Mapping一配置：我们就可以使用Contrller的 [类名.do]来访问这个Controller.&lt;bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"&gt;&lt;/bean&gt;HandlerMapping架构图总结：多个映射器可以共存。相互不影响。&emsp;&emsp;测试策略：三个映射器全部存在于配置文件中，使用映射器的不同访问方式，全部可以访问成功。HandlerAdapterSimpleControllerHandlerAdapterSimpleControllerHandlerAdapter: 执行controller，调用controller里面方法，返回modelAndView。&emsp;&emsp;表示所有实现了org.springframework.web.servlet.mvc.Controller 接口的Bean 可以作为Spring Web MVC 中的处理器。如果需要其他类型的处理器可以通过实现 HadlerAdapter 来解决。案例分析：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485① 模拟一个handlerAdapter//定义一个Adapter接口 public interface HandlerAdapter &#123; public boolean supports(Object handler); public void handle(Object handler); &#125; ② 模拟一个Controller//以下是三种Controller实现 public interface Controller &#123; &#125; public class HttpController implements Controller&#123; public void doHttpHandler()&#123; System.out.println("http..."); &#125; &#125; public class SimpleController implements Controller&#123; public void doSimplerHandler()&#123; System.out.println("simple..."); &#125; &#125; public class AnnotationController implements Controller&#123; public void doAnnotationHandler()&#123; System.out.println("annotation..."); &#125; &#125; ③ 适配器 //下面编写适配器类 public class SimpleHandlerAdapter implements HandlerAdapter &#123; public void handle(Object handler) &#123; ((SimpleController)handler).doSimplerHandler(); &#125; public boolean supports(Object handler) &#123; return (handler instanceof Controller); &#125; &#125; public class HttpHandlerAdapter implements HandlerAdapter &#123; public void handle(Object handler) &#123; ((HttpController)handler).doHttpHandler(); &#125; public boolean supports(Object handler) &#123; return (handler instanceof Controller); &#125; &#125; public class AnnotationHandlerAdapter implements HandlerAdapter &#123; public void handle(Object handler) &#123; ((AnnotationController)handler).doAnnotationHandler(); &#125; public boolean supports(Object handler) &#123; return (handler instanceof Controller); &#125; &#125; ④ DispatcherServletpublic class Dispatcher &#123; public static List&lt;HandlerAdapter&gt; handlerAdapters = new ArrayList&lt;HandlerAdapter&gt;(); public DispatchServlet()&#123; handlerAdapters.add(new AnnotationHandlerAdapter()); handlerAdapters.add(new HttpHandlerAdapter()); handlerAdapters.add(new SimpleHandlerAdapter()); &#125; public void doDispatch()&#123; //此处模拟SpringMVC从request取handler的对象，仅仅new出，可以出， //不论实现何种Controller，适配器总能经过适配以后得到想要的结果 // HttpController controller = new HttpController(); // AnnotationController controller = new AnnotationController(); SimpleController controller = new SimpleController(); //得到对应适配器 HandlerAdapter adapter = getHandler(controller); //通过适配器执行对应的controller对应方法 adapter.handle(controller); &#125; public HandlerAdapter getHandler(Controller controller)&#123; for(HandlerAdapter adapter: this.handlerAdapters)&#123; if(adapter.supports(controller))&#123; return adapter; &#125; &#125; return null; &#125; public static void main(String[] args)&#123; new DispatchServlet().doDispatch(); &#125; &#125;&emsp;&emsp;通过一个简单的Adapter源码分析，发现原来适配器功能这么强大，设计的如此精妙，果然不同凡响。HttpRequestHandlerAdapter&emsp;&emsp;HTTP请求处理器适配器将http请求封装成HttpServletResquest 和HttpServletResponse对象，和servlet接口类似123456789101112131415161718192021222324252627282930第一步：配置HttpRequestHandlerAdapter适配器 &lt;!-- 配置HttpRequestHandlerAdapter适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"&gt;&lt;/bean&gt;第二步：编写Controllerpublic class HttpRequestController implements HttpRequestHandler&#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute("message", "我是中国人"); request.getRequestDispatcher("/WEB-INF/jsps/mess.jsp").forward(request, response); &#125;&#125;第三步：准备jsp页面&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这是我的第二个适配器&lt;/h1&gt;&lt;h1&gt;$&#123;message &#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;第四步：调试运行总结：适配器可以共存，只是控制器实现不同的接口使用不同的适配器而已。&emsp;&emsp;注意：SimpleControllerHandlerAdapter是默认的适配器。如果使用后面这个适配器必须手动配置。否则将会访问失败。&emsp;&emsp;实现了HttpRequestHandler接口：配置文件里面没有配置这个适配器报如下错误：&emsp;&emsp;No adapter for handler [springMVC_01.HttpRequestController@12d527f]: Does your handler implement a supported interface like Controller?&emsp;&emsp;通过这个错误,我们发现：实现Controller接口是默认的，既是说明：SimpleControllerHandlerAdapter是默认的适配器&emsp;&emsp;还必须注意：实现HttpRequestHandler接口的控制器不支持ControllerClassNameHandlerMapping这个处理器映射器。控制器控制器架构图Controller 简介1、收集、验证请求参数并绑定到命令对象；2、将命令对象交给业务对象，由业务对象处理并返回模型数据；3、返回ModelAndView（Model部分是业务对象返回的模型数据，视图部分为逻辑视图名）。ServletForwardingController(转发控制器)1234567891011121314151617181920//将接收到的请求转发到一个命名的servlet，具体示例如下：public class ForwardingServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().write("Controller forward to Servlet"); &#125; &#125; &lt;servlet&gt; &lt;servlet-name&gt;forwarding&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.javass.chapter4.web.servlet.ForwardingServlet&lt;/servlet-class&gt; &lt;/servlet&gt; //当我们请求/forwardToServlet时，会被转发到名字为“forwarding”的servlet处理，该sevlet的servlet-mapping标签配置是可选的。&lt;!— 在springmvc.xml配置处理器 --&gt; &lt;bean name="/forwardToServlet" class="org.springframework.web.servlet.mvc.ServletForwardingController"&gt; &lt;property name="servletName" value="forwarding"&gt;&lt;/property&gt; &lt;/bean&gt;命令控制器(AbstractCommandController)通过get请求方式传递参数① 命令控制器编写1234567891011121314151617181920public class CommandController extends AbstractCommandController&#123; public CommandController() &#123; this.setCommandClass(Student.class); &#125; @Override /** * command:命令对象 * errors：数据绑定出现错误 */ protected ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object command, BindException errors) throws Exception &#123; // TODO Auto-generated method stub Student s = (Student) command; System.out.println(s); ModelAndView mv = new ModelAndView(); mv.setViewName("add/success"); return mv; &#125; &#125;② 配置bean12&lt;!-- 配置命令控制器bean --&gt; &lt;bean name="/add.do" class="springMVC_01.CommandController"&gt;&lt;/bean&gt;③ 编写JSP页面(add/add.jsp)④ 传递参数访问路径：localhost:8080/springmvc/add.do?name=zhangsan&amp;password=123使用post请求进行表单提交模拟提交学生表单信息：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950① 编写跳转命令控制器(跳转到添加页面)/** * command:命令对象 * errors：数据绑定出现错误 */ protected ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object command, BindException errors) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.setViewName("add/add"); return mv; &#125; ② 编写编辑页面控制器(填写添加数据)@Override /** * command:命令对象 * errors：数据绑定出现错误 */ protected ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object command, BindException errors) throws Exception &#123; Student s = (Student) command; System.out.println(s); ModelAndView mv = new ModelAndView(); mv.setViewName("add/success"); return mv; &#125; @Override protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception &#123; // 设置将页面字符串类型的数据转换成命令对象中Date属性,注意：这里的Date类型和命令对象的Date都使用Java.util.Date binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), true)); &#125;//也可以进行条件判断：进行时间类型各种格式的覆盖 ③ 添加页面&lt;form action="$&#123;pageContext.request.contextPath &#125;/add.do" method="post"&gt; 姓名:&lt;input type="text" name="name"&gt;&lt;br/&gt; 密码:&lt;input type="text" name="password"&gt;&lt;br/&gt; 日期:&lt;input type="text" name="birthday"&gt;&lt;br/&gt;&lt;input type="submit" value="提交"&gt; &lt;br/&gt; &lt;/form&gt;④ 成功页面&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;成功提示页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;恭喜登陆！！！&lt;/h1&gt;&lt;/body&gt;参数控制器(ParameterizableViewController)12345&lt;bean name="/toIndex.do" class="org.springframework.web.servlet.mvc.ParameterizableViewController"&gt; &lt;!-- 配置你所要跳转到视图的名称 --&gt; &lt;property name="viewName" value="index"&gt;&lt;/property&gt;//跳转到index页面 &lt;/bean&gt;//注意：使用参数控制器：不用自己定义Controller，可以直接使用toIndex进行访问使用注解的方式实现SpringMVC注解快速入门新建一个web工程并导入jar包配置springMVC配置文件123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd"&gt; &lt;!-- 添加注解扫描!!! --&gt; &lt;context:component-scan base-package="cn.itcast"&gt;&lt;/context:component-scan&gt; &lt;!-- 添加注解映射器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- 注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsps/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; &lt;!-- 注解映射器和注解适配器可以使用&lt;mvc:annotation-driven /&gt;代替。 &lt;mvc:annotation-driven /&gt;默认注册了注解映射器和注解适配器等bean。 --&gt;配置web.xml文件123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;springMVC_01&lt;/display-name&gt; &lt;!-- 配置编码过滤器，解决post请求的乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;character&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;character&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置springmvc框架，设置springmvc配置文件路径 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;编写Controller12345678@Controller@RequestMapping("/user")public class MyOneController &#123; @RequestMapping("/fun") public String fun()&#123; return "hello"; &#125;&#125;编写hello的JSP页面Controller@Controller：用于标识是处理器类.表示把我的控制器对象交给spring来创建。Controller起作用：只需要扫描即可。12&lt;!-- 添加注解扫描!!! --&gt; &lt;context:component-scan base-package="cn.itcast"&gt;&lt;/context:component-scan&gt;RequestMapping&emsp; &emsp;@RequestMapping：请求到处理器功能方法的映射规则；&emsp;&emsp;URL路径映射：@RequestMapping(value=&quot;/user&quot;)或@RequestMapping(&quot;/user&quot;)&emsp;&emsp;RequestMapping请求方法限定：get、postGet请求乱码&emsp;&emsp;对于get请求中文参数出现乱码解决方法有两个：&emsp;&emsp;修改tomcat配置文件添加编码与工程编码一致，如下：&lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;&emsp;&emsp;另外一种方法对参数进行重新编码：123String userName =newString(request.getParamter("userName").getBytes("ISO8859-1"),"utf-8")ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码Post请求&emsp;&emsp;在web.xml中加入：123456789101112&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&emsp;&emsp;URL模板映射需求：将修改请求方式改变123456789101112131415161718@RequestMapping(value="/useredit/&#123;userId&#125;")：&#123;×××&#125;占位符，请求的URL可以是“/useredit/001”或“/useredit/abc”，通过在方法中使用@PathVariable获取&#123;×××&#125;中的×××变量 @RequestMapping("/useredit/&#123;userid&#125;") public String useredit(@PathVariable String userid,Model model) throws Exception&#123; //方法中使用@PathVariable获取useried的值，使用model传回页面 model.addAttribute("userid", userid); return"/user/useredit"; &#125;//实现restFul,所有的url都是一个资源的链接，有利于搜索引擎对网址收录。//多个占位符： @RequestMapping("/useredit/&#123;groupid&#125;/&#123;userid&#125;") public String useredit(@PathVariable String groupid,@PathVariable String userid,Model model) throws Exception&#123; //方法中使用@PathVariable获取useried的值，使用model传回页面 model.addAttribute("groupid", groupid); model.addAttribute("userid", userid); return "/user/useredit"; &#125;&emsp;&emsp;根路径+子路径12345678根路径： @RequestMapping放在类名上边，如下： @Controller @RequestMapping("/user")子路径 @RequestMapping放在方法名上边，如下： @RequestMapping("/useradd") public String useradd(…&emsp;&emsp;请求方法限定12345678910111213• @RequestMapping(method = RequestMethod.GET)如果通过Post访问则报错：HTTP Status 405 - Request method 'POST' not supported例如：@RequestMapping(value="/useredit/&#123;userid&#125;",method=RequestMethod.GET)• 限定POST方法@RequestMapping(method = RequestMethod.POST)如果通过Post访问则报错：HTTP Status 405 - Request method 'GET' not supported• GET和POST都可以@RequestMapping(method=&#123;RequestMethod.GET,RequestMethod.POST&#125;)&emsp;&emsp;需要注解映射器(默认使用)12&lt;!-- 添加注解映射器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt;&emsp;&emsp;需要使用注解适配器(默认使用)12&lt;!-- 注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;&lt;/bean&gt;&emsp;&emsp;参数传递【请求参数绑定】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115////默认支持的参数类型////HttpServletRequest、HttpResponse，HttpSession、Model………….////基本类型参数(Integer、Long、boolean)//////布尔型：&lt;tr&gt; &lt;td&gt;用户状态：&lt;/td&gt; &lt;td&gt; &lt;input type="radio" name="userstate" value="true"/&gt; &lt;input type="radio" name="userstate" value="false"/&gt;&lt;/td&gt;&lt;/tr&gt;@RequestMapping("/fun") public String fun(String userName,Integer age)&#123; return "hello"; &#125; ////Pojo对象(Object)////@RequestMapping("/fun") public String fun(Model model,User user)&#123; return "hello"; &#125;//对比Struts2使用属性驱动进行封装参数//业务需求：//假如：现在有多个pojo、并且里面具有相同的属性，如果现在还使用基本的对象封装方式，那么将会出现错误。//那么这个问题怎么解决呢？//解析：我们使用包装类来包装pojo、经过包装的pojo相当于加了一层包结构。所以后面即使具有相同的属性也无所谓。Public class UserVo &#123; private User user; public User getUser() &#123; return user; &#125; Public void setUser(User user) &#123; this.user = user; &#125; &#125;//页面定义：&lt;input type="text" name="user.age" /&gt;&lt;input type="text" name="user.birthday" /&gt;//Controller方法定义如下：public String useraddsubmit(Model model,UserVo userVo)throws Exception&#123; System.out.println(userVo.getUser());&#125;////数组(Array)//////页面定义如下：//页面选中多个checkbox向controller方法传递&lt;input type="checkbox" name="ids" value="001"/&gt;&lt;input type="checkbox" name=" ids " value="002"/&gt;&lt;input type="checkbox" name=" ids " value="002"/&gt;//修改时可以采用循环模式 @RequestMapping("/fun") public String fun(Model model,Integer[] ids)&#123; return "hello"; &#125; ////集合(collection)//////集合页面：// List中存放对象，并将定义的List放在包装类中，controller使用包装对象接收。//List中对象：public class StudentScore &#123;//成绩对象 private String coursename;//课程名称 private Float score;//成绩 public String getCoursename() &#123; returncoursename; &#125; Public void setCoursename(String coursename) &#123; this.coursename = coursename; &#125; public Float getScore() &#123; returnscore; &#125; Public void setScore(Float score) &#123; this.score = score; &#125;&#125;Public class UserVo &#123; Private List&lt;StudentScore&gt; scores;//成绩 //get/set方法..&#125;//页面：&lt;tr&gt; &lt;td&gt;课程成绩：&lt;/td&gt; &lt;td&gt; 课程名：&lt;input type="text"name="scores[0].coursename"/&gt;成绩：&lt;input type="text"name="scores[0].score"/&gt;&lt;br/&gt; 课程名：&lt;input type="text"name="scores[1].coursename"/&gt;成绩：&lt;input type="text"name="scores[1].score"/&gt;&lt;br/&gt; 课程名：&lt;input type="text"name="scores[2].coursename"/&gt;成绩：&lt;input type="text"name="scores[2].score"/&gt;&lt;br/&gt; &lt;/td&gt;&lt;/tr&gt;//Contrller方法定义如下：public String useraddsubmit(Model model,UserVo userVo)throws Exception&#123; System.out.println(userVo.getScores ());&#125;////Map////// 在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收。// 包装类中定义Map对象如下：Public class UserVo &#123; private Map&lt;String, Object&gt;studentinfo = new HashMap&lt;String, Object&gt;(); //get/set方法..&#125;页面定义如下：&lt;tr&gt; &lt;td&gt;学生信息：&lt;/td&gt; &lt;td&gt; 姓名：&lt;inputtype="text"name="studentinfo['name']"/&gt; 年龄：&lt;inputtype="text"name="studentinfo['age']"/&gt; .. .. .. &lt;/td&gt;&lt;/tr&gt;Contrller方法定义如下：public String useraddsubmit(Model model,UserVo userVo)throws Exception&#123; System.out.println(userVo.getStudentinfo());&#125;RequestParam-value：参数名字，即入参的请求参数名字，如value=“studentid”表示请求的参数区中的名字为studentid的参数的值将传入；-required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报400错误码；-defaultValue：默认值，表示如果请求中没有同名参数时的默认值定义如下：123456public String userlist(@RequestParam(defaultValue="2",value="group",required=true) String groupid)&#123;&#125;//形参名称为groupid，但是这里使用value="group"限定参数名为group，所以页面传递参数的名必须为group。这里通//过required=true限定groupid参数为必需传递，如果不传递则报400错误，由于使用了defaultvalue=”2”默认值即使//不传group参数它的值为”2”，所以页面不传递group也不会报错，如果去掉defaultvalue=”2”且定义required=true//则如果页面不传递group则会报错。Redirect&emsp;&emsp;Contrller方法返回结果重定向到一个url地址，如下方式：return &quot;redirect:/user/userlist.do&quot;;注意：redirect:add.do 与 redirect:/user/add.do” 同一个类在同一个类里面进行跳转。上面2个都可以实现跳转。但是有区别：第一个是同一个根路径下面跳转。第二个是在项目路径下进行跳转。 不同的类进行跳转&emsp;&emsp;不同的类进行跳转只能使用：redirect:/user/add.do进行跳转。即是从项目路径下来查询。&emsp;&emsp;redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。&emsp;&emsp;由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/user/userlist.do后边加参数，如下：/user/userlist.action?groupid=2&amp;…..Forward&emsp;&emsp;controller方法执行后继续执行另一个controller方法。return &quot;forward:/user/userlist.action&quot;;&emsp;&emsp;forward方式相当于request.getRequestDispatcher().forward(request,response)，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。如下例子：12345678910 @RequestMapping("/c")public String c(String groupid,UserVo userVo)throws Exception&#123; System.out.println("...c...."+groupid+"...user..."+userVo.getUser()); return "forward:/to/d.action";&#125; @RequestMapping("/d")public String d(String groupid,UserVo userVo)throws Exception&#123; System.out.println("...d...."+groupid+"...user..."+userVo.getUser()); return "success";&#125;RequestBody/ResponseBody处理Json数据作用：@RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上。本例子应用：@RequestBody注解实现接收http请求的json数据，将json数据转换为java对象请求Json响应Json添加处理json数据配置12345678&lt;!-- 注解适配器 ：添加json转换器--&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;编写代码【请求json、返回json】123456789@Controller@RequestMapping("json")public class MyJsonController &#123; @RequestMapping("requestJson.do") public @ResponseBody User requestJson(Model model,@RequestBody User u)&#123; System.out.println("用户信息:"+u); return u; &#125;&#125;编写页面ajax12345678910111213141516171819202122232425262728&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath &#125;/js/jquery-1.9.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //请求json，返回json function request_json()&#123; var user = JSON.stringify(&#123;userName:"张思德",age:21&#125;); $.ajax(&#123; type:'POST',//请求方式 url: '$&#123;pageContext.request.contextPath&#125;/json/requestJson.do',//请求地址 contentType:'application/json;charset=utf-8',//发送数据类型 data:user,//传递数据 success : function(data)&#123; //请求成功后的回调函数 alert(data.userName+":"+data.age); &#125; &#125;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" onclick="request_json()" value="请求json，返回json"&gt;&lt;/body&gt;&lt;/html&gt;请求pojo响应json添加处理json数据配置【同上】前台请求数据构造：key=value&amp;key=value.编写Controller代码123456789@Controller@RequestMapping("json")public class MyJsonController &#123; @RequestMapping("responseJson.do") public @ResponseBody User responseJson(User user)&#123; System.out.println(user); return user; &#125;&#125;编写页面代码1234567891011121314151617181920212223242526&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath &#125;/js/jquery-1.9.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; //请求pojo，返回json function response_json()&#123; $.ajax(&#123; type:'POST', url: '$&#123;pageContext.request.contextPath&#125;/json/responseJson.do', data:'userName=张三&amp;age=12', success : function(data)&#123; alert(data.userName+":"+data.age); &#125; &#125;) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" onclick="response_json()" value="请求pojo，返回json"&gt;&lt;/body&gt;&lt;/html&gt;&lt;mvc:annotation-driven /&gt;配置：注解映射器和注解适配器可以使用&lt;mvc:annotation-driven /&gt;代替。&lt;mvc:annotation-driven /&gt;默认注册了注解映射器和注解适配器等bean。如下：1234567891011以下配置可用&lt;mvc:annotation-driven /&gt;代替：&lt;!--注解映射器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt; &lt;!--注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;多视图&emsp;&emsp;视图是展示给用户的内容，控制器先得到对应的数据模型，对于非逻辑视图，则直接将数据模型渲染便结束；对于逻辑视图，则要先通过视图解析器对其进一步解析，以定位真实视图。对多视图的配置12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 相当于配置requestmapping和requestAdapter以及json支持 --&gt; &lt;mvc:annotation-driven/&gt;&lt;!-- 配置视图解析器 --&gt;&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsps/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;！-- 配置多视图解析 --&gt;&lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;!-- 配置支持媒体类型 --&gt; &lt;property name="contentNegotiationManager"&gt; &lt;bean class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean"&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;entry key="json" value="application/json"&gt;&lt;/entry&gt; &lt;entry key="xml" value="application/xml"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!-- 指定默认视图 --&gt; &lt;property name="defaultViews"&gt; &lt;!-- 支持多个视图 --&gt; &lt;list&gt; &lt;!-- 对josn格式视图支持 --&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJacksonJsonView"&gt;&lt;/bean&gt; &lt;!-- xml格式视图支持 --&gt; &lt;bean class="org.springframework.web.servlet.view.xml.MarshallingView"&gt; &lt;constructor-arg&gt; &lt;bean class="org.springframework.oxm.jaxb.Jaxb2Marshaller"&gt; &lt;property name="classesToBeBound"&gt; &lt;list&gt; &lt;value&gt;cn.itcast.domain.User&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;123456789//Controller代码@RequestMapping("multiView")public User multiView()&#123; User user1 = new User(); user1.setId(1); ... user1.setAddress("武当山"); return user1;&#125;多视图解析需要结合restful风格使用，访问 ：multiView.xml||json 验证注意json视图需要导入jackson相关包xml视图需要导入spring-oxm相关包springMVC的其他视图：freemaker&emsp;&emsp;freemaker是springmvc本身的视图解析器，可以实现页面静态化准备工作导包：freemaker.jar准备相关文件(index.ftl)修改springmvc配置文件123456789101112131415161718&lt;bean id="freeMarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt; &lt;property name="templateLoaderPath" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt; &lt;property name="freemarkerSettings"&gt; &lt;props&gt; &lt;prop key="template_update_delay"&gt;0&lt;/prop&gt; &lt;prop key="default_encoding"&gt;UTF-8&lt;/prop&gt; &lt;prop key="number_format"&gt;0.##########&lt;/prop&gt; &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt; &lt;prop key="classic_compatible"&gt;true&lt;/prop&gt; &lt;prop key="template_exception_handler"&gt;ignore&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;bean class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"&gt; &lt;property name="suffix" value=".ftl"&gt;&lt;/property&gt; &lt;property name="contentType" value="text/html;charset=utf-8"&gt;&lt;/property&gt;&lt;/bean&gt;编写controllerftl文件内容格式123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mata charset="utf-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ////遍历List//// //定义数据 Map root = new HashMap(); List&lt;String&gt; persons = new ArrayList&lt;String&gt;(); persons.add("范冰冰"); persons.add("李冰冰"); persons.add("何灵"); root.put("persons", persons); // &lt;#list persons as person&gt; $&#123;person&#125; &lt;/#list&gt; //页面 &lt;#list persons as p&gt; $&#123;p.id&#125;/$&#123;p.name&#125; &lt;/#list&gt; //// 在模板中赋值 //// 1:&lt;#assign x=0 /&gt; $&#123;x&#125; 2:&lt;#assign x="$&#123;world&#125;" /&gt; $&#123;x&#125; 3:&lt;#assign x&gt;世界太好了&lt;/#assign&gt; $&#123;x&#125; 4:&lt;#assign x&gt; &lt;#list ["星期一", "星期二", "星期三", "星期四", "星期五", "星期六", "星期天"] as n&gt; $&#123;n&#125; &lt;/#list&gt; &lt;/#assign&gt; $&#123;x&#125; &lt;/body&gt;&lt;/html&gt;页面缓存(oscache为例)需求：使用页面缓存来提高用户体验度相关概念缓存原理优点：提升性能缺点：不访问数据库，不是实时数据分布式缓存&emsp;&emsp;分布式缓存能控制颗粒的大小，分布式缓存使用的是redis，memcached等等。这相当于是数据库，那么我们是不是在任何一层都可以进行操作数据库。所以可以进行颗粒大小的控制。使用oscache管理缓存准备工作在src根目录下创建oscache.properties1234//oscache.properties常用参数cache.memory=false//不能缓存内存cache.persistence.class=com.opensymphony.oscache.plugins.diskpersistence.DiskPersistenceListener//持久化类cache.path=F:\\cache//持久化到F盘导入oscacha-2.4.1.jar配置缓存过滤器oscache的使用123456789&lt;!-- 在jsp页面中导入oscache标签库 --&gt;&lt;%@ taglib uri="http://www.opensymphony.com/oscache" prefix="oscache" %&gt;&lt;!-- 在body中使用标签控制缓存的部分 --&gt;&lt;oscache:cache&gt;&lt;!-- 缓存默认保存在application中，可在标签中加入"scope='session'"属性,将缓存保存在session中 --&gt;&lt;!-- 若想让缓存不随路径变化而变，可通过加入key属性实现 --&gt;...&lt;/oacache:cache&gt;注意&emsp;&emsp;缓存是通过“url=页面缓存”的形式保存的，故当请求地址发生变化后，缓存就不起作用了文件上传&emsp;&emsp;需求分析：使用响应json格式数据的形式上传图片并回显准备工作导入jar文件(fileupload、io、jersey-client、jersey-core)配置视图解析器1234&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 文件上传的最大值，单位为byte --&gt; &lt;property name="maxUploadSize" value="10240000"/&gt;&lt;/bean&gt;代码编写1234567891011121314151617181920212223242526272829303132333435363738394041@Controller@RequestMapping("/upload")public class UploadController &#123; @RequestMapping("/uploadPic") public void uploadPic(HttpServletRequest request,HttpServletResponse response,String fileName,PrintWriter out)&#123; //将普通请求转换为多部件请求方式 MultipartHttpServletRequest mh = (MultipartHttpServletRequest) request; //根据文件名进行获取文件对象 CommonsMultipartFile cm = (CommonsMultipartFile) mh.getFile(fileName); //把多部件文件对象转换为字节 byte[] fbytes = cm.getBytes(); //定义文件名 String newFileName=""; SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmssSSS"); newFileName= sdf.format(new Date()); //再加上三位随机数 Random ran = new Random(); for(int i=0;i&lt;3;i++)&#123; newFileName = newFileName+ran.nextInt(10); &#125; //获取上传文件的扩展名 String suffix=""; String originalFilename = cm.getOriginalFilename(); suffix=originalFilename.substring(originalFilename.lastIndexOf(".")); //创建jersy客户端 Client client = Client.create(); //指定关联文件图片服务器地址 WebResource resource = client.resource(SSMConstants.PIC_HOST+"/upload/"+newFileName+suffix); //跨服务器上传图片 resource.put(String.class, fbytes); String fullPath=SSMConstants.PIC_HOST+"/upload/"+newFileName+suffix; String relativePath="/upload/"+newFileName+suffix; //&#123;"":"","":""&#125; String result="&#123;\"fullPath\":\""+fullPath+"\",\"relativePath\":\""+relativePath+"\"&#125;"; //JSONObject jsonObject = JSON.parseObject(result); out.print(result); &#125;1234567891011121314151617181920212223242526272829//页面回显ajax&lt;p&gt;&lt;label&gt;&lt;/label&gt; &lt;img id='imgSize1ImgSrc' src='$&#123;picPath &#125;$&#123;item.pic &#125;' height="100" width="100" /&gt; &lt;input type='file' id='imgSize1File' name='imgSize1File' class="file" onchange='submitImgSize1Upload()' /&gt; &lt;span class="pos" id="imgSize1FileSpan"&gt;请上传图片的大小不超过3MB&lt;/span&gt; &lt;input type='hidden' id='imgSize1' name='pic' value='' reg="^.+$" tip="亲！您忘记上传图片了。" /&gt; &lt;/p&gt; function submitUpload()&#123; var opt = &#123; //重新指定form的action的值 url:"$&#123;path&#125;/upload/uploadPic.do", type:"post", dateType:"text", data:&#123; fileName:"imgsFile" &#125;, success:function(responseText)&#123; var obj = $.parseJSON(responseText); $("#imgsImgSrc").attr("src",obj.fullPath); $("#imgs").val(obj.fileName); &#125;, error:function()&#123; alert("系统错误"); &#125; &#125;; $("#form111").ajaxSubmit(opt); &#125;拦截器定义&emsp;&emap;SpringWebMVC的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理局部拦截器&emsp;&emsp;针对某个handlerMapping进行配置只对当前HandlerMapping有效。123456789101112//在配置文件中的配置&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt; &lt;property name="interceptors"&gt; &lt;list&gt; &lt;ref bean="handlerInterceptor1"/&gt; &lt;ref bean="handlerInterceptor2"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; &lt;bean id="handlerInterceptor1" class="springmvc.intercapter.HandlerInterceptor1"/&gt; &lt;bean id="handlerInterceptor2" class="springmvc.intercapter.HandlerInterceptor2"/&gt;拦截器的代码实践:实现HandlerInterceptor123456789101112131415161718192021222324252627282930313233Public class HandlerInterceptor1 implements HandlerInterceptor&#123; /** * controller执行前调用此方法 * 返回true表示继续执行，返回false中止执行 * 这里可以加入登录校验、权限拦截等 */ @Override Public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // TODO Auto-generated method stub Return false; &#125; /** * controller执行后但未返回视图前调用此方法 * 这里可在返回用户前对模型数据进行加工处理，比如这里加入公用信息以便页面显示 */ @Override Public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // TODO Auto-generated method stub&#125; /** * controller执行后且视图返回后调用此方法 * 这里可得到执行controller时的异常信息 * 这里可记录操作日志，资源清理等 */ @Override Public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125;全局拦截器12345678910111213//相关配置&lt;!--拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;!--多个拦截器,顺序执行 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean class="cn.itcast.springmvc.filter.HandlerInterceptor1"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean class="cn.itcast.springmvc.filter.HandlerInterceptor2"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;拦截器测试123456789101112131415161718//测试1拦截器1放行，拦截器2放行：HandlerInterceptor1.........preHandleHandlerInterceptor2.........preHandleHandlerInterceptor2.........postHandleHandlerInterceptor1.........postHandleHandlerInterceptor2.........afterCompletionHandlerInterceptor1.........afterCompletion//测试2拦截器1放行，拦截器2阻止：HandlerInterceptor1.........preHandleHandlerInterceptor2.........preHandleHandlerInterceptor1.........afterCompletion//测试3：拦截器1阻止，拦截器2阻止：HandlerInterceptor1.........preHandle拦截器的应用（用户身份认证）123456789101112131415161718Public class LoginInterceptor implements HandlerInterceptor&#123; @Override Public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //如果是登录页面则放行 if(request.getRequestURI().indexOf("login.action")&gt;=0)&#123; return true; &#125; HttpSession session = request.getSession(); //如果用户已登录也放行 if(session.getAttribute("user")!=null)&#123; return true; &#125; //用户没有登录挑战到登录页面 request.getRequestDispatcher("/WEB-INF/jsp/login.jsp").forward(request, response); return false; &#125;&#125;SSM整合(SpringMVC,Spring,Mybatis)&emsp;&emsp;为了更好的学习Springmvc和mybatis整合开发的方法，需要将Springmvc和mybatis进行整合，整合目标为：控制层采用SpringMvc，持久层使用mybatis实现需求&emsp;&emsp;实现商品查询列表，从mysql数据库查询商品信息jar包&emsp;&emsp;包括：Spring（包括SpringMvc），mybatis，mybatis-Spring整合包，数据库驱动，第三方连接池Dao&emsp;&emsp;目标：spring管理SqlSessionFactory、mapper详细参考mybatis教程与spring整合章节。db.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatisjdbc.username=XXXXjdbc.password=XXXXlog4j.properties123456# Global logging configuration，建议开发环境中要用debuglog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%nsqlMapConfig.xml1234567891011//在classpath下创建mybatis/sqlMapConfig.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!—使用自动扫描器时，mapper.xml文件如果和mapper.java接口在一个目录则此处不用定义mappers --&gt;&lt;mappers&gt;&lt;package name="cn.itcast.ssm.mapper" /&gt;&lt;/mappers&gt;&lt;/configuration&gt;applicationContext-dao.xml配置数据源、事务管理，配置SqlSessionFactory、mapper扫描器。1234567891011121314151617181920212223242526272829303132333435363738&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt;&lt;!-- 加载配置文件 --&gt;&lt;context:property-placeholder location="classpath:db.properties"/&gt;&lt;!-- 数据库连接池 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="maxActive" value="30"/&gt; &lt;property name="maxIdle" value="5"/&gt;&lt;/bean&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis/SqlMapConfig.xml" /&gt; &lt;/bean&gt;&lt;!-- mapper扫描器 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.itcast.springmvc.mapper"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt;&lt;/bean&gt;&lt;/beans&gt;ItemsMapper.xml12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.itcast.ssm.mapper.ItemsMapper"&gt; &lt;!-- sql片段 --&gt; &lt;!-- 商品查询条件 --&gt; &lt;sql id="query_items_where"&gt; &lt;if test="items!=null"&gt; &lt;if test="items.name!=null and items.name!=''"&gt; and items.name like '%$&#123;items.name&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt; &lt;!-- 查询商品信息 --&gt; &lt;select id="findItemsList" parameterType="queryVo" resultType="items"&gt; select * from items &lt;where&gt; &lt;include refid="query_items_where"/&gt; &lt;/where&gt; &lt;/select&gt; &lt;/mapper&gt;ItemsMapper.java1234public interface ItemsMapper &#123; //商品列表 public List&lt;Items&gt; findItemsList(QueryVo queryVo) throws Exception;&#125;Service&emsp;&emsp;目标:Service由spring管理；spring对service进行事务控制applicationContext-service.xml&emsp;&emsp;配置service接口ApplicationContext-transaction.xml123456789101112131415161718192021222324252627282930313233343536373839404142////配置事务管理器&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt;&lt;!-- 事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;!-- 通知 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="save*" propagation="REQUIRED"/&gt; &lt;tx:method name="insert*" propagation="REQUIRED"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 切面 --&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* cn.itcast.springmvc.service.impl.*.*(..))"/&gt;&lt;/aop:config&gt;&lt;/beans&gt;OrderService12345678910public interface OrderService &#123; @Autowired private ItemsMapper itemsMapper; @Override public List&lt;Items&gt; findItemsList(QueryVo queryVo) throws Exception &#123; //查询商品信息 return itemsMapper.findItemsList(queryVo); &#125;&#125;Actionspringmvc.xml12345678910111213141516171819202122232425262728293031&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 扫描controller注解,多个包中间使用半角逗号分隔 --&gt; &lt;context:component-scan base-package="cn.itcast.ssm.controller"/&gt; &lt;!--注解映射器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt; &lt;!--注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt; &lt;!-- ViewResolver --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView" /&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt;&lt;/beans&gt;web.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253////加载spring容器，配置springmvc前置控制器。&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;springmvc&lt;/display-name&gt; &lt;!-- 加载spring容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/spring/applicationContext.xml,/WEB-INF/classes/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- springmvc的前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+"-servlet.xml" --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt;OrderController1234567891011121314151617@Controllerpublic class OrderController &#123; @Autowired private OrderService orderService; @RequestMapping("/queryItem.action") public ModelAndView queryItem() throws Exception &#123; // 商品列表 List&lt;Items&gt; itemsList = orderService.findItemsList(null); // 创建modelAndView准备填充数据、设置视图 ModelAndView modelAndView = new ModelAndView(); // 填充数据 modelAndView.addObject("itemsList", itemsList); // 视图 modelAndView.setViewName("order/itemsList"); return modelAndView; &#125;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>ssm</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂项]]></title>
    <url>%2F2018%2F08%2F15%2F%E6%9D%82%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[目录java相关linux相关python相关java相关Class类中的getCanonicalName(), getName(), getSimpleName()getCanonicalName() 是获取所传类从java语言规范定义的格式输出。 //getCanonicalName()=com.pinzhi.test.dao.DaoEntitygetName() 是返回实体类型名称 //getName()=com.pinzhi.test.dao.DaoEntitygetSimpleName() 返回从源代码中返回实例的名称。//getSimpleName()=DaoEntitylinux相关问题1 ：虚拟机环境下Ubuntu登录后只显示桌面背景解决方案：按alt+ctrl+F1进入命令行模式，使用sudo apt-get install ubuntu-desktop重新安装桌面Python相关yield与yield from 关键字的性质&emsp;&emsp;为了探究两个关键字的性质，使用print的方式测试了他们的一些性质。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#yield_from.py#定义两个函数，htest()&amp;itest()#在主方法中调用itest()，itest()通过yield from调用htest()def htest(): print('htest run...') i = 0 key = 0 while i &lt; 4: n = yield key if n == 4: p = 100 else: p = n key = p print('h[',i,']:',key) i += 1def itest(): print('itest() start') h = htest() k = 0 h.send(None) while True: d = yield k print('d=',d) print('yield from htest()') val1 = yield from htest() print('itest1:', val1) val2 = yield from htest() print('itest2:', val2) e = yield k print('e=',e) try: print('th:',h.send(e)) except StopIteration as e: print('h error!!!') print('itest() end')if __name__ == '__main__': t = itest() t.send(None) j = 0 while j &lt; 12: j += 1 try: t.send(j) except StopIteration as e: print('error!!!')&emsp;&emsp;运行结果如下:&emsp;&emsp;由代码可以看出两个关键字有如下特点：对于一个coroutine函数，首先要用send()方法传入一个None，开启这个函数coroutine函数传入参数的个数，由函数内的循环次数决定（即如果为无限循环时，可能会导致另一个coroutine函数无法接收参数），传入的参数个数超过循环次数则会抛出’StopIteration‘异常coroutine函数内通过 a = yield b或 a = yield from b（）的方式接受传入的值，若是用变量接收，变量可为任意变量，但一定要是已定义的变量，接收变量后，可通过 b = xxx或return xxx设定外部函数的返回值;若是使用yield from的方式，则要求后面的函数是coroutine函数。参数传入是按顺序传入的。可以将yield from看做是一个数组，比如先用yield传值，后面接上一个yield from，则先将一个值传给yield，再将后面长度为yield from数组的数传入该函数中使用yield from 方法时，若是直接传输给一个函数即yield from xxx(),每次传输都会重新开始循环；若是使用在循环外h =coroutine() h.send(None)开启coroutine函数，在循环中用yield h接受传入的值，则每次运行都会从继续上一次的状态开始python中的文件操作有以下语句：12with open(filepath,'xt') as f: f.write('Hello\n')理解为：x模式是Python3中对open()函数的拓展，用来代替W模式对一个不存在文件系统的文件操作。xt 模式下，若是filepath中的文件已存在，会抛出FileExistsError。To be continue…]]></content>
      <categories>
        <category>待整理</category>
      </categories>
      <tags>
        <tag>零散知识</tag>
        <tag>待整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[j2ee开发相关工具的配置与使用]]></title>
    <url>%2F2018%2F08%2F03%2Fj2ee%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[导入SVN略，待补充Mavenmaven简介什么是maven？&emsp;&emsp;Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。Maven是跨平台的项目管理工具。主要服务于基于Java平台的项目构建，依赖管理和项目信息管理。Maven主要有两个功能：项目构建依赖管理什么是构建？项目构建的3种方式Eclipse&emsp;&emsp;手工操作较多，项目的构建过程都是独立的，很难一步完成。比如：编译、测试、部署等。开发时每个人的IDE配置都不同，很容易出现本地代码换个地方编译就出错Ant&emsp;&emsp;Ant只是一个项目构建工具，它没有集成依赖管理。Ant在进行项目构建时，它没有对项目目录结构进行约定，需要手动指定源文件、类文件等目录地址。同时它执行task时，需要显示指定依赖的task，这样会造成大量的代码重复。Maven&emsp;&emsp;Maven不仅是一个项目构建工具，更是一个项目管理工具。它在项目构建工程中，比ant更全面，更灵活。Maven在进行项目构建时，它对项目目录结构拥有约定，知道你的源代码在哪里，类文件应该放到哪里去。它拥有生命周期的概念，maven的生命周期是有顺序的，在执行后面的生命周期的任务时，不需要显示的配置前面任务的生命周期。例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程maven模型maven基本结构maven的工程结构Project|-src| &emsp; |-main| &emsp; | &emsp; |-java —— 存放项目的.java文件| &emsp; | &emsp; |-resources —— 存放项目资源文件，如spring, hibernate配置文件| &emsp; |-test| &emsp;&emsp;&emsp;|-java ——存放所有测试.java文件，如JUnit测试类| &emsp;&emsp;&emsp;|-resources —— 测试资源文件|-target —— 目标文件输出位置例如.class、.jar、.war文件|-pom.xml ——maven项目核心配置文件maven的命令需要在pom.xml所在目录中执行以下命令。Mvn compile&emsp;&emsp;执行 mvn compile命令，完成编译操作&emsp;&emsp;执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。Mvn clean&emsp;&emsp;执行 mvn clean命令&emsp;&emsp;执行完毕后，会将target目录删除。Mvn test&emsp;&emsp;执行 mvn test命令，完成单元测试操作&emsp;&emsp;执行完毕后，会在target目录中生成三个文件夹：surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件）Mvn package&emsp;&emsp;执行 mvn package命令，完成打包操作&emsp;&emsp;执行完毕后，会在target目录中生成一个文件，该文件可能是jar、warMvn install&emsp;&emsp;执行 mvn install命令，完成将打好的jar包安装到本地仓库的操作&emsp;&emsp;执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用mvn clean compile命令&emsp;&emsp;cmd 中录入 mvn clean compile命令&emsp;&emsp;组合指令，先执行clean，再执行compile，通常应用于上线前执行，清除测试类mvn clean test命令&emsp;&emsp;cmd 中录入 mvn clean test命令&emsp;&emsp;组合指令，先执行clean，再执行test，通常应用于测试环节mvn clean package命令&emsp;&emsp;cmd 中录入 mvn clean package命令&emsp;&emsp; 组合指令，先执行clean，再执行package，将项目打包，通常应用于发布前执行过程：清理————清空环境编译————编译源码测试————测试源码打包————将编译的非测试类打包mvn clean install命令&emsp;&emsp;cmd 中录入 mvn clean install 查看仓库，当前项目被发布到仓库中&emsp;&emsp; 组合指令，先执行clean，再执行install，将项目打包，通常应用于发布前执行过程：清理————清空环境编译————编译源码测试————测试源码打包————将编译的非测试类打包部署————将打好的包发布到资源仓库中M2eclipse&emsp;&emsp;M2Eclipse是eclipse中的maven插件安装配置M2Eclipse若是版本较老的Eclipse，没有集成maven插件需要进行以下步骤：将包中的插件复制到eclipse中的dropins目录中在eclipse的“preference”查看eclipse中是否有maven插件在maven—&gt;installation中设置maven安装目录在maven—&gt;user setting中设置用户配置创建maven工程的基本流程选择new→maven→Maven Project一直next，选择maven的工程骨架，这里我们选择quickstart。输入GroupId、ArtifactId、Version、Package信息点击finish完成。maven核心概念坐标坐标的概念&emsp;&emsp;和在平面几何中坐标（x,y）可以标识平面中唯一的一点相似。在maven中坐标就是为了定位一个唯一确定的jar包。Maven世界拥有大量构建，我们需要找一个用来唯一标识一个构建的统一规范拥有了统一规范，就可以把查找工作交给机器。maven坐标的组成groupId:定义当前Maven组织名称artifactId:定义实际项目名称//如cn.itcast.mavenversion:定义当前项目的当前版本依赖管理&emsp;&emsp;就是对项目中jar包的管理，可以在pom文件中定义jar包的GAV坐标，管理依赖。依赖声明主要包括如下元素：12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/denpendency&gt;&lt;/dependencies&gt;依赖范围&emsp;&emsp;其中，依赖范围scope 用来控制依赖和编译，测试，运行的classpath的关系. 主要的是三种依赖关系如下：compile： 默认编译依赖范围。对于编译，测试，运行三种classpath都有效test：测试依赖范围。只对于测试classpath有效provided：已提供依赖范围。对于编译，测试的classpath都有效，但对于运行无效。因为由容器已经提供，例如servlet-apiruntime:运行时提供。例如:jdbc驱动依赖传递直接依赖和间接依赖&emsp;&emsp;若B中使用A，C中使用B，则称B是C的直接依赖，而称A是C的间接依赖。C-&gt;B B-&gt;A //C直接依赖B,C间接依赖A依赖范围对传递依赖的影响左边第一列表示第一直接依赖范围上面第一行表示第二直接依赖范围中间的交叉单元格表示传递性依赖范围。总结：当第二依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致。当第二直接依赖的范围是test的时候，依赖不会得以传递。当第二依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为 provided；当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile例外，此时传递的依赖范围为runtime；依赖冲突若直接与间接依赖中包含有同一个坐标不同版本的依赖，以直接依赖的版本为准（就近原则）从如下例子可以看出：Maven-first工程依赖log4j-1.2.8版本, Maven-second无依赖，那么maven-third中依赖的是log4j-1.2.8若在前面的基础上，Maven-second依赖log4j-1.2.9，那么maven-third中依赖的是log4j-1.2.9若直接依赖中包含同一坐标不同版本的资源依赖，以配置文件下方的为准可选依赖&emsp;&emsp;在依赖中添加optional选项决定此依赖是否向下传递，如果是true则不传递，如果是false就传递，默认为false。123456789&lt;denpendencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.itcast&lt;/groupId&gt; &lt;artifactId&gt;maven-first&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 决定此依赖是否向下传递，true不传递，false传递 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;排除依赖&emsp;&emsp;排除依赖包中所包含的依赖关系，不需要添加版本号。如果在本次依赖中有一些多余的jar包也被传递依赖过来，如果想把这些jar包排除的话可以配置exclusions进行排除。1234567891011121314&lt;dependency&gt; &lt;groupId&gt;cn.itcast&lt;/groupId&gt; &lt;artifactId&gt;maven-first&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 配置要排除的jar包 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;!-- 此处只需要groupId和artifactId，不需要版本号， 此配置将排除所有版本 --&gt; &lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-first&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;生命周期什么是生命周期？&emsp;&emsp;Maven生命周期就是为了对所有的构建过程进行抽象和统一。包括项目清理、初始化、编译、打包、测试、部署等几乎所有构建步骤。生命周期可以理解为构建工程的步骤。&emsp;&emsp;在Maven中有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是：Clean Lifecycle： 在进行真正的构建之前进行一些清理工作。Default Lifecycle： 构建的核心部分，编译，测试，打包，部署等等。Site Lifecycle： 生成项目报告，站点，发布站点。&emsp;&emsp;再次强调一下它们是相互独立的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。Maven三大生命周期clean：清理项目&emsp;&emsp;每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。有Clean生命周期，也有clean阶段。Clean生命周期一共包含了三个阶段：pre-clean 执行一些需要在clean之前完成的工作clean 移除所有上一次构建生成的文件post-clean 执行一些需要在clean之后立刻完成的工作&emsp;&emsp;mvn clean 中的clean就是上面的clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvn clean 等同于 mvn pre-clean clean ，如果我们运行 mvn post-clean ，那么 pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。default:构建项目&emsp;&emsp;Default生命周期是Maven生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里，只解释一些比较重要和常用的阶段：validateinitializegenerate-sourcesprocess-sources :处理项目主资源文件。一般来说，是对src/main/resource目录的内容进行变量替换等工作后，复制到项目输出的主classpath目录中generate-resourcesprocess-resources 复制并处理资源文件，至目标目录，准备打包。compile 编译项目的源代码。一般来说，就是编译src/main/java目录下的java文件到项目输出的主classpath目录中process-classesgenerate-test-sourcesprocess-test-sources ：处理项目测试资源文件，一般来说，是对src/test/resource目录的内容进行变量替换等工作后，复制到项目输出的测试classpath目录中generate-test-resourcesprocess-test-resources 复制并处理资源文件，至目标测试目录。test-compile 编译测试源代码。process-test-classestest 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。prepare-packagepackage 接受编译好的代码，打包成可发布的格式，如 JAR 。pre-integration-testintegration-testpost-integration-testverifyinstall 将包安装至本地仓库，以让其它项目依赖。deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享。&emsp;&emsp;运行任何一个阶段的时候，它前面的所有阶段都会被运行，这也就是为什么我们运行mvn install 的时候，代码会被编译，测试，打包。此外，Maven的插件机制是完全依赖Maven的生命周期的，因此理解生命周期至关重要。site：生成项目站点&emsp;&emsp;Site生命周期：pre-site 执行一些需要在生成站点文档之前完成的工作site 生成项目的站点文档post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备site-deploy 将生成的站点文档部署到特定的服务器上&emsp;&emsp;这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。Maven插件&emsp;&emsp;Maven的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。每个插件都能实现一个功能，每个功能就是一个插件目标。Maven的生命周期与插件目标相互绑定，以完成某个具体的构建任务。例如compile就是插件maven-compiler-plugin的一个插件目标Maven编译插件123456789101112131415&lt;!-- 在dependencies标签后 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 指定编译java1.7版本的源文件 --&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;Tomcat插件&emsp;&emsp;写完以下配置后，可通过tomcat7:run 运行tomcat7（推荐，但是需要添加插件）123456789&lt;plugin&gt; &lt;!-- 配置插件 --&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt;&lt;/plugin&gt;继承&emsp;&emsp;继承是为了消除重复，可以把很多相同的配置提取出来。例如：grouptId，version等，具体步骤如下：创建父工程（即创建一个packaging为pom的工程）创建子工程&emsp;&emsp;创建方式有两种：&emsp;&emsp;&emsp;&emsp;一种是创建新工程为子工程，在创建时设置父工程的GAV。&emsp;&emsp;&emsp;&emsp;一种是修改原有的工程为子工程，在子工程的pom.xml文件中手动添加父工程的GAV。12345678910111213&lt;!-- 在pom.xml中 --&gt;&lt;project ....&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 配置父工程gav --&gt; &lt;parent&gt; &lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;cn.itcast.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-subt&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/project&gt;父工程可以做到的操作如下：父工程中对依赖进行的配置，在子工程中都会继承此依赖使用&lt;dependencyManagement&gt;可以管理依赖的版本号（即若子工程中有相同的依赖，可以不指定版本号，使用父工程中指定的版本号）父工程可以使用&lt;properties&gt;&lt;log4j.version&gt;1.2.9&lt;/log4j.version&gt;...&lt;/properties&gt;的形式定义版本号，在&lt;dependencyManagement&gt;中通过&lt;version&gt;${log4j.version}&lt;/version&gt;的形式统一管理版本号聚合&emsp;&emsp;聚合一般是一个工程拆分成多个模块开发，每个模块是一个独立的工程，但是要是运行时必须把所有模块聚合到一起才是一个完整的工程，此时可以使用maven的聚合工程。例如电商项目中，包括商品模块、订单模块、用户模块等。就可以对不同的模块单独创建工程，最终在打包时，将不同的模块聚合到一起。例如同一个项目中的表现层、业务层、持久层，也可以分层创建不同的工程，最后打包运行时，再聚合到一起。创建聚合工程的步骤创建聚合工程，打包方式为pom(用来放置子模块)通过new- - - Maven Module创建子模块工程（若为表现层要将打包方式设置为war）修改聚合工程的pom.xml文件12345&lt;!-- 在gav下添加如下内容 --&gt;&lt;modules&gt; &lt;module&gt;模块的artifactId&lt;/module&gt; ... &lt;/modules&gt;Maven仓库管理什么是Maven仓库？&emsp;&emsp;用来统一存储所有Maven共享构建的位置就是仓库。根据Maven坐标定义每个构建在仓库中唯一存储路径大致为：groupId/artifactId/version/artifactId-version.packaging仓库的分类本地仓库(每个用户只有一个本地仓库)~/.m2/repository远程仓库中央仓库：Maven默认的远程仓库，不包含版权资源http://repo1.maven.org/maven2私服：是一种特殊的远程仓库，它是架设在局域网内的仓库私服安装nexus&emsp;&emsp;为所有来自中央仓库的构建安装提供本地缓存。下载网站：http://nexus.sonatype.org/&emsp;&emsp;安装版本：nexus-2.7.0-06.war第一步：将下载的nexus的war包复制到tomcat下的webapps目录。第二步：启动tomcat。nexus将在c盘创建sonatype-work目录【C:\Users\当前用户\sonatype-work\nexus】。目录结构如下：nexus的仓库简介仓库有4种类型 :group(仓库组)：一组仓库的集合hosted(宿主)：配置第三方仓库 （包括公司内部私服 ）proxy(代理)：私服会对中央仓库进行代理，用户连接私服，私服自动去中央仓库下载jar包或者插件virtual(虚拟)：兼容Maven1 版本的jar或者插件Nexus的仓库和仓库组介绍:3rd party: 一个策略为Release的宿主类型仓库，用来部署无法从公共仓库获得的第三方发布版本构建Apache Snapshots: 一个策略为Snapshot的代理仓库，用来代理Apache Maven仓库的快照版本构建Central: 代理Maven中央仓库Central M1 shadow: 代理Maven1 版本 中央仓库Codehaus Snapshots: 一个策略为Snapshot的代理仓库，用来代理Codehaus Maven仓库的快照版本构件Releases: 一个策略为Release的宿主类型仓库，用来部署组织内部的发布版本构件Snapshots: 一个策略为Snapshot的宿主类型仓库，用来部署组织内部的快照版本构件Public Repositories:该仓库组将上述所有策略为Release的仓库聚合并通过一致的地址提供服务nexus的使用访问访问URL: http://localhost:8080/nexus-2.7.0-06/默认账号:&emsp;&emsp;用户名： admin&emsp;&emsp;密码： admin123在本地仓库的setting.xml中配置如下(即配置所有构建均从私服下载)12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;!--此处配置所有的构建均从私有仓库中下载 *代表所有，也可以写central --&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://localhost:8080/nexus-2.7.0-06/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;未完待续]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>svn</tag>
        <tag>maven</tag>
        <tag>ssh</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记]]></title>
    <url>%2F2018%2F07%2F30%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Tips:本笔记主要信息来源为传智播客的《60集精通java教程Spring框架开发》,笔记内容为：学习资料 + 个人补充；如有内容或排版方面的错误，欢迎纠正~内容分布spring概念和ioc入门（ioc操作xml配置文件）spring的ioc操作（注解）和aop概念jdbcTemplate和spring管理事务ssh框架整合[开发]1Spring概念与IOC入门Spring概念Spring是开源的轻量级框架Spring的核心包括两个部分&emsp;&emsp;-aop：面向切面编程，扩展功能不是修改源代码实现&emsp;&emsp;-ioc：控制反转&emsp;&emsp;&emsp;&emsp;- 比如有一个类，在类里面有方法（不是静态的方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象。在这里，对象的创建不是通过new方式实现，而是交给spring配置创建类对象spring是一站式框架&emsp;&emsp;spring在javaee三层结构中，每一层都提供不同的解决技术&emsp;&emsp;&emsp;&emsp;- web层：springMVC&emsp;&emsp;&emsp;&emsp;- service层：spring的ioc&emsp;&emsp;&emsp;&emsp;- dao层：spring的jdbcTemplateSpring的版本&emsp;&emsp;-hibernate：5.x&emsp;&emsp;-Spring4.x（这里学习的版本）Spring的ioc操作把对象的创建交给spring进行管理ioc操作两部分：1）ioc的配置文件方式2）ioc的注解方式IOC底层原理ioc底层原理使用技术（1）xml配置文件（2）dom4j解决xml（3）工厂设计模式（4）反射画图分析ioc实现原理IOC和DI区别IOC: 控制反转，把对象创建交给spring进行配置DI: 依赖注入，向类里面的属性中设置值关系：依赖注入不能单独存在，需要在ioc基础之上完成操作Spring整合web项目原理Spring整合web项目原理加载spring核心配置文件ApplicationContext context = new ClasssPathXmlApplicationContext(&quot;xml路径&quot;)//new 对象;的方法，功能可以实现，效率很低实现思想：把加载配置文件和创建对象过程，在服务器启动时候完成实现原理（1）ServletContext对象（2）监听器（3）具体使用：在服务器启动时候，为每个项目创建一个ServletContext对象在ServletContext对象创建时候，使用监听器可以具体到ServletContext对象在什么时候创建使用监听器监听到ServletContext对象创建时候，加载spring配置文件，把配置文件配置对象创建把创建出来的对象放到ServletContext域对象里面（setAttribute方法）获取对象时候，到ServletContext域得到（getAttribute方法）Spring整合web项目演示导包struts2相关jar包：Spring相关jar包Spring-web整合包:Spring-web-3.0.7.jar(myeclipse2015可支持的最高版本)代码实现之准备部分1234567891011121314151617181920//---UserService.java---public class UserService &#123; private UserDao userDao; public void add()&#123; System.out.println("service........"); userDao.add(); &#125; public UserDao getUserDao() &#123; return userDao; &#125; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;&#125;//---UserDao.java---public class UserDao &#123; public void add()&#123; System.out.println("dao........"); &#125;&#125;代码实现之Spring与struts2配置文件1234567891011121314151617181920212223&lt;!------ applicationContext.xml ------&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 配置userDao和userService --&gt; &lt;bean id="userDao" class="cn.pinzhi.dao.UserDao"&gt;&lt;/bean&gt; &lt;bean id="userService" class="cn.pinzhi.service.UserService"&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;&lt;!------ struts.xml------&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;package name="spring_web" namespace="/" extends="struts-default"&gt; &lt;action name="userAction" class="cn.pinzhi.action.UserAction" method="execute"&gt;&lt;/action&gt; &lt;/package&gt;&lt;/struts&gt;代码实现之spring与struts2的整合12345678910111213141516171819202122232425262728293031323334353637//------web.xml------&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;spring_web&lt;/display-name&gt; &lt;!-- 重要：配置struts2的核心过滤器 --&gt; &lt;!--配置struts2的过滤器，要放到其他过滤器后面，保证其他过滤器可以执行 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 指定Spring配置文件的位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:bean2.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt;//-----UserAction.java----public class UserAction extends ActionSupport&#123; @Override public String execute() throws Exception &#123; System.out.println("action...."); ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext()); UserService userService = (UserService)ctx.getBean("userService"); userService.add(); return NONE; &#125;&#125;验证通过访问 localhost:8080\项目名\UserAction.action 验证Spring的bean管理（xml）bean实例化的方式&emsp;&emsp;在Spring中通过配置文件创建对象bean实例化的三种方式&emsp;&emsp;&emsp;1.使用类的无参构造方法创建（重点）12&lt;!-- 若类中没有无参构造方法，会出现异常。 --&gt;&lt;bean id=“user” class=“cn.itcast.ioc.User”&gt;&lt;/bean&gt;&emsp;&emsp;&emsp;2.使用静态工厂创建123456789101112 //创建静态的方法，返回类对象 //Bean2Factory.java public class Bean2Factory&#123; //静态的方法，返回Bean2对象 public static Bean2 getBean2()&#123; return new Bean2(); &#125; &#125;//applicationContext.xml &lt;!-- 使用静态工厂创建对象 --&gt; &lt;bean id=“bean2” class=“cn.itcast.bean.Bean2Factory” factory-method=“getBean2”&gt;&lt;/bean&gt;&emsp;&emsp;&emsp;3.使用实例工厂创建12345678910111213 // Bean3Factory.java//创建非静态方法，返回类对象 public class Bean3Factory&#123; //普通的方法，返回Bean3对象 public Bean3 getBean3()&#123; return new Bean3(); &#125;&#125;//applicationContext.xml&lt;!-- 使用实例工厂创建对象--&gt;&lt;bean id="bean3Factory" class="cn.itcast.bean.Bean3Factory"&gt;&lt;/bean&gt;&lt;bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3"&gt;&lt;/bean&gt;Bean标签常用属性id属性：起名称，id属性值名称任意命名id属性值，不能包含特殊符号根据id值得到配置对象class属性：创建对象所在类的全路径name属性：功能和id属性一样的，id属性值不能包含特殊符号，但是在name属性值里面可以包含特殊符号scope属性singleton：默认值，单例prototype：多例request：创建对象把对象放到request域里面session：创建对象把对象放到session域里面globalSession：创建对象把对象放到globalSession里面属性注入属性注入介绍&emsp;&emsp;创建对象时候，向类里面属性里面设置值属性注入的方式的三种方式使用set方法注入(重点)使用有参数构造注入使用接口注入! 在spring框架里面，支持前两种方式12345678910111213 //使用有参数构造注入属性&lt;!-- 第一种：构造方法的方式 --&gt; &lt;bean id="car" class="cn.itcast.spring.demo4.Car"&gt; &lt;constructor-arg name="name" value=" 保 时 捷 "/&gt; &lt;constructor-arg name="price" value="1000000"/&gt; &lt;/bean&gt;//------------------------------------------//使用set方法注入属性（重点）&lt;!-- 第二种：set方法的方式 --&gt; &lt;bean id="car2" class="cn.itcast.spring.demo4.Car2"&gt; &lt;property name="name" value=" 奇 瑞 QQ"/&gt; &lt;property name="price" value="40000"/&gt; &lt;/bean&gt;注入对象类型属性（重点）具体实现过程（1）在service里面把dao作为类型属性（2）生成dao类型属性的set方法（3）配置文件中注入关系相关代码：1234567891011121314151617//------------------------------------public class UserService&#123; //定义一个service类，dao类为类的属性 private UserDao userDao; //在service类中包含dao属性的set方法 public void setUserDao(UserDao userDao)&#123; this.userDao=userDao; &#125;&#125;//------------------------------------&lt;bean id="userDao" class="cn.itcast.dao.UserDao" /&gt;&lt;!-- 注入对象类型的属性 --&gt; &lt;bean id="person" class="cn.itcast.spring.demo4.Person"&gt; &lt;property name="name" value=" 会 希 "/&gt; &lt;!-- ref属性：引用另一个 bean的id或name --&gt; &lt;property name="car2" ref="car2"/&gt; &lt;/bean&gt;P名称空间注入(Spring2.x 版本后提供的方式)12345678910&lt;!--第一步:引入p名称空间 --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--第二步:使用p名称空间. * 普通属性: p:属性名称=”” * 对象类型属性: p:属性名称-ref=”” --&gt; &lt;!-- p名称空间的属性注入的方式 --&gt; &lt;bean id="car2" class="cn.itcast.spring.demo4.Car2" p:name=" 宝 马 7" p:price="1200000"/&gt; &lt;bean id="person" class="cn.itcast.spring.demo4.Person" p:name=" 思 聪 " p:car2-ref="car2"/&gt; &lt;/beans&gt;SpEL 的方式的属性注入(Spring3.x 版本后提供的方式)12345678910111213141516171819&lt;!--SpEL：Spring Expression Language. 语法:#&#123; SpEL &#125; --&gt;&lt;!-- SpEL的注入的方式 --&gt; &lt;bean id="car2" class="cn.itcast.spring.demo4.Car2"&gt; &lt;property name="name" value="#&#123;' 奔 驰 '&#125;"/&gt; &lt;property name="price" value="#&#123;800000&#125;"/&gt; &lt;/bean&gt;&lt;bean id="person" class="cn.itcast.spring.demo4.Person"&gt; &lt;property name="name" value="#&#123;'冠希'&#125;"/&gt; &lt;property name="car2" value="#&#123;car2&#125;"/&gt; &lt;/bean&gt;&lt;bean id="carInfo" class="cn.itcast.spring.demo4.CarInfo"&gt;&lt;/bean&gt;&lt;!--引用了另一个类的属性 --&gt;&lt;bean id="car2" class="cn.itcast.spring.demo4.Car2"&gt; &lt;!-- &lt;property name="name" value="#&#123;'奔驰'&#125;"/&gt; --&gt; &lt;property name="name" value="#&#123;carInfo.carName&#125;"/&gt; &lt;property name="price" value="#&#123;carInfo.calculatePrice()&#125;"/&gt; &lt;/bean&gt;注入复杂类型属性12345678910111213141516171819202122232425262728293031323334&lt;!-- Spring 的复杂类型的注入===================== --&gt; &lt;bean id="collectionBean" class="cn.itcast.spring.demo5.CollectionBean"&gt; &lt;!-- 数组类型的属性 --&gt; &lt;property name="arrs"&gt; &lt;list&gt; &lt;value&gt;会希&lt;/value&gt; &lt;value&gt;冠希&lt;/value&gt; &lt;value&gt;天一&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入List集合的数据 --&gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;芙蓉&lt;/value&gt; &lt;value&gt;如花&lt;/value&gt; &lt;value&gt;凤姐&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入Map集合 --&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="aaa" value="111"/&gt; &lt;entry key="bbb" value="222"/&gt; &lt;entry key="ccc" value="333"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- Properties 的注入 --&gt; &lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="username"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;123&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;Spring的Bean管理（注解）注解介绍：代码里面特殊标记，使用注解可以完成功能注解写法 @注解名称(属性名称=属性值)注解使用在类上面，方法上面 和 属性上面Spring注解开发准备导入jar包基本的jar包aop的jar包:Spring-aop-4.3.4.RELEASE.jar创建类，创建方法12345678910public interface UserDao &#123; public void sayHello();&#125;public class UserDaoImpl implements UserDao &#123; @Override public void sayHello() &#123; System.out.println("Hello Spring..."); &#125;&#125;创建spring配置文件，引入约束（1）第一天做ioc基本功能，引入约束beans（2）做spring的ioc注解开发，引入新的约束开启注解扫描12&lt;!-- Spring 的注解开发:组件扫描(类上注解: 可以直接使用属性注入的注解) --&gt; &lt;context:component-scan base-package="com.itheima.spring.demo1"/&gt;注解创建对象在创建对象的类上面使用注解实现1234567891011121314//通过注解注册Bean@Component(value="userDao") public class UserDaoImpl implements UserDao &#123; @Override public void sayHello() &#123; System.out.println("Hello Spring Annotation..."); &#125;&#125;//测试方法中获取bean对象@Test public void demo2() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext( "applicationContext.xml"); UserDao userDao = (UserDao) applicationContext.getBean("userDao"); userDao.sayHello(); &#125;创建对象有四个注解（目前这四个注解功能是一样的，都创建对象）（1）@Component（2）@Controller：web层（3）@Service：业务层（4）@Repository：持久层！ 指定创建对象单实例还是多实例的方法123456789//注解的方式@Service(value="user")//注解bean对象@Scope(value="prototype")//指定对象是多例，默认是单例：Singletonpublic class User&#123;...&#125;//配置文件的方式&lt;bean id="" class="" scope="singleton"&gt;&lt;/bean&gt;注解注入属性:(使用注解注入的方式,可以不用提供 set 方法.)@Value :用于注入普通类型.@Autowired :自动装配: * 默认按类型进行装配.按名称注入:@Qualifier:强制使用名称注入.@Resource相当于:@Autowired和@Qualifier一起使用.示例：123456789101112//创建dao和service对象@Component("userDao")//value值可以省略public class UserDao&#123;...&#125;@Service("userService")//目前功能与Component相同public class UserService&#123; @Autowired//根据类名自动匹配属性 private UserDao userDao; @Resource(name="userDao")//通过bean名字匹配属性 private UserDao userDao2;配置文件和注解混合使用12345678910//使用配置文件方式实现创建对象操作&lt;!-- 配置对象--&gt;&lt;bean id="bookDao" class="xxx.xx.xxx.bookDao"&gt;&lt;/bean&gt;&lt;bean id="bookService" class="xx.xx.xx.BookService"&gt;&lt;/bean&gt;//使用注解方式注入属性public class BookService&#123; @Resource(name="bookDao") private BookDao bookDao;&#125;AOPAOP相关概念AOP：面向切面（方面）编程，在不修改源码的情况下扩展功能AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码AOP底层使用动态代理实现第一种情况，有接口情况，（JDK 的动态代理 ）使用动态代理创建接口实现类代理对象第二种情况，没有接口情况，（ Cglib 的动态代理）使用动态代理创建类的子类代理对象AOP原理12345678910111213141516171819202122232425//Cglib 动态代理增强一个类中的方法:public class MyCglibProxy implements MethodInterceptor&#123; private CustomerDao customerDao; public MyCglibProxy(CustomerDao customerDao)&#123; this.customerDao = customerDao; &#125; // 生成代理的方法: public CustomerDao createProxy()&#123; // 创建Cglib的核心类: Enhancer enhancer = new Enhancer(); // 设置父类: enhancer.setSuperclass(CustomerDao.class); // 设置回调: enhancer.setCallback(this); // 生成代理： CustomerDao customerDaoProxy = (CustomerDao) enhancer.create(); return customerDaoProxy; &#125; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; if("delete".equals(method.getName()))&#123; Object obj = methodProxy.invokeSuper(proxy, args); System.out.println("日志记录================"); return obj; &#125; return methodProxy.invokeSuper(proxy, args); &#125;&#125;Spring 的基于 AspectJ 的 AOP 开发在spring里面进行aop操作，使用aspectj实现（1）aspectj不是spring一部分，和spring一起使用进行aop操作（2）Spring2.0以后新增了对AspectJ支持使用aspectj实现aop有两种方式（1）基于aspectj的xml配置（2）基于aspectj的注解方式AOP操作术语Joinpoint(连接点): 类里面可以被增强的方法，这些方法称为连接点Pointcut(切入点):所谓切入点是指我们要对哪些Joinpoint进行拦截的定义.Advice(通知/增强):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为:前置通知；后置通知；异常通知；最终通知；环绕通知(切面要完成的功能)Aspect(切面): 是切入点和通知（引介）的结合Introduction(引介):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field.Target(目标对象):代理的目标对象(要增强的类)Weaving(织入):是把增强应用到目标的过程.把advice 应用到 target的过程Proxy（代理）:一个类被AOP织入增强后，就产生一个结果代理类切入点表达式&emsp;切入点，即实际增强的方法表达式格式为execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)（1）execution(* cn.itcast.aop.Book.add(..))（2）execution(* cn.itcast.aop.Book.*(..))（3）execution(* *.*(..))（4） 匹配所有save开头的方法 execution(* save*(..))Spring 使用 AspectJ 进行 AOP 的开发：XML 的方式（*）导包&emsp;除了导入基本的jar包之外，还需要导入aop相关的jar包创建配置文件，导入aop约束1234567&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;/beans&gt;编写切面类12345678910public class MyAspectXml &#123; // 定义前置增强方法 public void before()&#123; System.out.println("前置增强==========="); &#125; // 定义后置增强方法 public void methodName()&#123; System.out.println("后置增强==========="); &#125; &#125;配置切入点123456789101112&lt;!-- 配置切面类 --&gt; &lt;bean id="myAspectXml" class="cn.itcast.spring.demo3.MyAspectXml"&gt;&lt;/bean&gt;&lt;!-- 进行 aop的配置 --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式:哪些类的哪些方法需要进行增强 --&gt; &lt;aop:pointcut expression="execution(* cn.itcast.spring.demo3.OrderDao.*(..))" id="pointcut1"/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref="myAspectXml"&gt; &lt;aop:before method="before" pointcut-ref="pointcut1"/&gt; &lt;aop:after method="methodName" pointcut-ref="pointcut1"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;编写测试程序12345678@Testpublic void testOrderDao()&#123; //获取applicationContext ApplicationContext ctx = new ClassPathXmlApplicationContext("bean2.xml"); //使用接口类取得Bean OrderDao orderDao = (OrderDao)ctx.getBean("orderDao"); orderDao.save();&#125;Spring 使用 AspectJ 进行 AOP 的开发：注解的方式创建对象123&lt;!-- 创建对象 --&gt;&lt;bean id="book" class="cn.pinzhi.aop.Book"&gt;&lt;/bean&gt;&lt;bean id="myBook" class="cn.pinzhi.aop.MyBook"&gt;&lt;/bean&gt;在配置文件中开启aop操作12&lt;!-- 开启aop操作 --&gt;&lt;aop:aspect-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;在增强类上使用注解12345678@Aspectpublic class MyBook&#123; //在方法上使用注解完成增强配置 @Before(value="execution(* cn.itcast.aop.Book.*(..)）") public void Before1()&#123; System.out.println("before..."); &#125;&#125;Spring的jdbcTemplate操作jdbcTemplate引入spring框架一站式框架（1）针对javaee三层，每一层都有解决技术（2）在dao层，使用 jdbcTemplatespring对不同的持久化层技术都进行封装jdbcTemplate使用和dbutils使用很相似，都数据库进行crud操作用jdbcTemplate实现增删改导入jdbcTemplate使用的jar包spring-jdbc-4.2.4.RELEASE.jarspring-tx-4.2.4.RELEASE.jarjdbc-connector-xx.jar(依赖包)创建对象，设置数据库信息创建jdbcTemplate对象，设置数据源调用jdbcTemplate对象里面的方法实现操作int update(String sql,Object… args);12345678910111213141516171819202122232425262728@Testpublic void update()&#123; //设置数据库信息 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName("com.mysql.jdbc.Driver"); dataSource.setUrl("jdbc:mysql://localhost:3306/Spring_day03"); dataSource.setUsername("root"); dataSource.setPassword("root"); //创建jdbcTemplate对象，设置数据源 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); //调用jdbcTemplate里的方法实现操作 //增 String sql1 = "insert into user values(?,?)"; int rows1 = jdbcTemplate.update(sql1,"lucy","250"); System.out.println(rows1); //删 String sql2 = "delete from user where name=？"; int rows2 = jdbcTemplate.update(sql1,"lucy"); System.out.println(rows2); //增改 String sql3 = "update user set password=？where name =?"; int rows3 = jdbcTemplate.update(sql3,"250","lucy"); System.out.println(rows3);&#125;用jdbcTemplate实现查询操作回顾：jdbc上的查询操作1234567891011121314151617181920212223242526272829303132333435 Connection conn = null; PrepareStatement pstmt = null; ResultSet rs = null;try&#123; Class.forName("com.mysql.jdbc.Driver");//加载驱动 //创建连接 conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/Spring_day03","root","root"); //编写sql语句 String sql = "seelect * from user where username=?"; //预编译sql pstmt = conn.prepareStatement(sql); //设置参数 pstmt.setString(1,"lucy"); //执行sql语句 rs = pstmt.excuteQuery(); //遍历结果集 while(rs.next())&#123; //得到返回的结果 String username = rs.getString("username"); String password = rs.getString("password"); User user = new User(); user.setUsername(username); user.setPassword(password); System.out.println(user); &#125;&#125;catch(Exception e)&#123;&#125;finally&#123; try&#123; rs.close(); pstmt.close(); conn.close(); &#125;catch()&#123; &#125;&#125;jdbcTemplate上的查询操作查询的种类返回结果为一个值使用方法：T queryForObject(String sql,Class&lt;t&gt; re quiredType);//参数1：sql语句；参数2：返回值类型.class返回结果为一个对象使用方法：T queryForObject(String sqlRowMapper&lt;T&gt; rowMapper,Object... args);//参数1：sql语句；参数2：RowMapper接口(要自己写);参数3：可变参数返回结果为List集合使用方法：List&lt;T&gt; query(String sqlRowMapper&lt;T&gt; rowMapper,Object... args);//参数1：sql语句；参数2：RowMapper接口(要自己写);参数3：可变参数实现过程：12345678910111213141516171819202122232425262728293031323334 //创建dataSource（略） //创建jdbaTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); //单值查询 String sql = "select count(*) from user"; int count = jdbcTemplate.queryForObject(sql,Interger.class); System.out.println(count); //对象查询 String sql = "select * from user where name=?"; User user = jdbcTemplate.queryForObject(sql,new MyRowMapper(),"marry"); System.out.println(user); //对象集合查询 String sql = "select * from user"; List&lt;User&gt; users = jdbcTemplate.queryForObject(sql,new MyRowMapper()); System.out.println(users);//-------Mapper.java---------class MyRowMapper implements RowMapper&lt;User&gt;&#123; @Override public User mapRow(ResultSet rs,int num)throws SQLException&#123; //从结果集中得到数据 String username = rs.getString("username"); String password = rs.getString("password"); //把得到的数据封装到对象中 User user = new User(); user.setUsername(username); user.setPassword(password); return user; &#125;&#125;Spring配置连接池和dao使用jdbcTemplateSpring配置c3p0连接池导包c3p0-0.9.2.1.jarmchange-commons-java-0.2.3.4.jar在Spring配置文件中配置连接池12345678&lt;!-- 配置c3p0连接池--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!-- 注入属性值 --&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/Spring_day03"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;在dao中使用jdbcTemplate配置xml文件后就可以直接使用连接池123456789101112131415//---- 创建service和dao，配置service和dao对象----//--------applicationContext.xml-------&lt;!-- 注入JdbcTemplate对象--&gt;&lt;bean id="jdbcTemplate" class="org.springframwork.jdbc.core.JdbaTemplate"&gt; &lt;!-- 注入dataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="userDao" class="cn.itcast.c3p0.UserDao"&gt; &lt;!-- 注入jdbcTemplate对象 --&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"&gt;&lt;/bean&gt;&lt;/bean&gt;&lt;bean id="userService" class="cn.itcast.c3p0.UserService"&gt; &lt;!-- 注入dao对象 --&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;&lt;/bean&gt;事务操作回顾：事务什么是事务？事务逻辑上的一组操作,组成这组操作的各个逻辑单元,要么一起成功,要么一起失败.事务特性:原子性 :强调事务的不可分割.一致性 :事务的执行的前后数据的完整性保持一致.隔离性 :一个事务执行的过程中,不应该受到其他事务的干扰持久性 :事务一旦结束,数据就持久到数据库如果不考虑隔离性引发安全性问题:脏读 :一个事务读到了另一个事务的未提交的数据不可重复读 :一个事务读到了另一个事务已经提交的 update 的数据导致多次查询结果不一致.虚读 :一个事务读到了另一个事务已经提交的 insert 的数据导致多次查询结果不一致.解决读问题:设置事务隔离级别未提交读 :脏读，不可重复读，虚读都有可能发生已提交读 :避免脏读。但是不可重复读和虚读有可能发生可重复读 :避免脏读和不可重复读.但是虚读有可能发生.串行化的 :避免以上所有读问题.Spring事务管理apispring事务管理两种方式第一种 编程式事务管理（不用）第二种 声明式事务管理（1） 基于xml配置文件实现（2） 基于注解实现相关代码1234567891011121314151617181920212223//------基于配置文件实现------//---Spring配置文件---&lt;!-- 第一步：配置事务管理器 --&gt;&lt;bean id="transactionManager" class= "org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入dataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 第二步：配置事务增强(前提：引入tx约束) --&gt;&lt;tx:advice id="txadvice" transaction-manager="transaction"&gt; &lt;!-- 做事务操作 --&gt; &lt;tx:attributes&gt; &lt;!-- 设置进行事务操作的方法匹配规则 --&gt; &lt;tx:meyhod name="acount*" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 第三步 配置切面 --&gt;&lt;aop:config&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression="execute(* cn.itcast.service.OrderService.*(..))" id="ponitcut1"/&gt; &lt;!-- 切面 --&gt; &lt;aop:advisor advice-ref="txadvice" pointcut-ref="pointcut1"/&gt;&lt;/aop:config&gt;1234567891011121314//------注解方式实现事务------&lt;!-- 第一步：配置事务管理器 --&gt;&lt;bean id="transactionManager" class= "org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入dataSource --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 第2步：开启事务注解 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;!-- 第3步：在要使用事务方法所在类上面添加注解 --&gt;@Transactionalpublic class OrderService&#123; ...&#125;TipsSpring分模块开发（将配置文件中的一部分分出去）12&lt;!-- 在主配置文件中，引入其他配置文件 --&gt;&lt;import resource="classpath:user.xml" /&gt;在最后&emsp;&emsp;Spring的基本内容已结束，随后还有ssh的整合部分，暂时不会去写，因为hibernate还没学习。谢谢你们的阅读To be continue…1. qqqqq &#8617;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>ssm</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记]]></title>
    <url>%2F2018%2F07%2F25%2Fmybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Tips：本笔记的内容主要来自传智播客mybatis学习视频的相关资料，以及一些实操后的补充。如有内容或排版方面的错误，欢迎纠正~篇幅较长，建议结合目录阅读Mybatis是什么？&emsp;&emsp; MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，实质上Mybatis对ibatis进行一些改进。&emsp;&emsp; MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。&emsp;&emsp; Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。分析原生态jdbc程序中存在的问题原生态Jdbc程序代码//原生态Jdbc程序代码 public static void** main(String[] args) { Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = **null**; try{ //1、加载数据库驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2、通过驱动管理类获取数据库链接 connection =DriverManager._getConnection_(&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;root&quot;); //3、定义sql语句 ?表示占位符 String sql = &quot;select * from user where username = ?&quot;; //4、获取预处理statement preparedStatement = connection.prepareStatement(sql); //5、设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, &quot;王五&quot;); //6、向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //7、遍历查询结果集 while(resultSet.next()){ System._out_.println(resultSet.getString(&quot;id&quot;)+&quot;&quot;+resultSet.getString(&quot;username&quot;)); } } catch(Exception e) { e.printStackTrace(); }finally{ //8、释放资源 if(resultSet!=null){ try{ resultSet.close(); } catch(SQLException e) { e.printStackTrace(); } } if(preparedStatement!=null){ try { preparedStatement.close(); } catch(SQLException e) { e.printStackTrace(); } } if(connection!=null){ try{ connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } } Jdbc问题总结数据库连接频繁开启和关闭，会严重影响数据库的性能。代码中存在硬编码，分别是数据库部分的硬编码和SQL执行部分的硬编码。Mybatis框架原理（核心）框架图分析结论mybatis配置文件，包括Mybatis全局配置文件和Mybatis映射文件，其中全局配置文件配置了数据源、事务等信息；映射文件配置了SQL执行相关的信息。mybatis通过读取配置文件信息（全局配置文件和映射文件），构造出SqlSessionFactory，即会话工厂。通过SqlSessionFactory，可以创建SqlSession即会话。Mybatis是通过SqlSession来操作数据库的。SqlSession本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。Executor接口有两个实现类，一个是普通执行器，一个是缓存执行器（默认）。Executor执行器要处理的SQL信息是封装到一个底层对象MappedStatement中。该对象包括：SQL语句、输入参数映射信息、输出结果集映射信息。其中输入参数和输出结果的映射类型包括java的简单类型、HashMap集合对象、POJO对象类型。Mybatis入门程序Mybatis课程的所有代码程序将通过一个订单商品案例来进行讲解。需求&emsp;&emsp; 对用户信息的增删改查操作。根据用户ID来查询用户信息；根据用户名称来模糊查询用户信息列表；添加用户删除用户（练习）修改用户（练习）环境准备Jdk环境：jdk1.7.0_72Ide环境：eclipse indigo数据库环境：MySQL 5.1Mybatis：3.2.7数据库初始化数据库脚本执行sql_table.sql脚本，创建数据库表；执行sql_data.sql初始化测试数据。数据库表订单商品案例的数据库脚本中，总共包含四张表，其中入门程序只使用user表.用户表的表结构如下：下载mybatismybaits的代码由github.com管理，下载地址：https://github.com/mybatis/mybatis-3/releasesLib：mybatis的依赖包Mybatis-3.2.7.jar：mybatis的核心包Mybatis-3.2.7.pdf：mybatis的使用指南工程搭建（三步）第一步：创建java工程用eclipse创建一个java工程，jdk使用1.7.0_72。第二步：加入jar包加入以下四部分jar包，其中junit的jar包，是非必须的。Mybatis核心包:mybaties-3.2.7.jarMybatis依赖包MySQL驱动包: mysql-connector-*Junit单元测试包（单元测试需要的包）:junit-4.9.jar第三步：添加log4j.properties文件Mybatis使用的日志包是log4j的，所以需要添加log4j.properties。在classpath下创建log4j.properties如下： //文件内容可以从mybatis-3.2.7.pdf中拷贝 # Global logging configuration log4j.rootLogger=DEBUG, stdout # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 日志级别在开发阶段设置成DEBUG，在生产阶段设置成INFO或者ERROR。编程步骤创建PO类，根据需求创建；创建全局配置文件SqlMapConfig.xml；编写映射文件；加载映射文件，在SqlMapConfig.xml中进行加载；编写测试程序，即编写Java代码，连接并操作数据库。&emsp; 思路：读取配置文件；通过SqlSessionFactoryBuilder创建SqlSessionFactory会话工厂。通过SqlSessionFactory创建SqlSession。调用SqlSession的操作数据库方法。关闭SqlSession。代码开发创建PO类&emsp; 创建的po类的属性要和数据库中表的列名一致（如果表中的列名是带有下划线，那么po类中对应的的属性名要采用驼峰式命名）&emsp;User.java类如下：//Public class User { private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 get/set…… 创建SqlMapConfig.xml配置文件&emsp; 在classpath下，创建SqlMapConfig.xml文件//SqlMapConfig.xml（文件头可以从mybatis-3.2.7.pdf文档的2.1.2小节中拷贝）： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 配置mybatis的环境信息 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源，采用dbcp连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 需求开发&emsp;在classpath下，创建sqlmap文件夹。在sqlmap目录下，创建User.xml映射文件。//Mybatis的映射文件头（可以从mybatis-3.2.7.pdf文件中拷贝）： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 根据用户ID来查询用户信息编写映射文件&emsp;在User.xml中添加以下代码：//&lt;!-- namespace：命名空间，它的作用就是对SQL进行分类化管理，可以理解为SQL隔离 注意：使用mapper代理开发时，namespace有特殊且重要的作用 --&gt; &lt;mapper namespace=&quot;test&quot;&gt; &lt;!-- 根据用户ID，查询用户信息 --&gt; &lt;!-- [id]：statement的id，要求在命名空间内唯一 [parameterType]：入参的java类型 [resultType]：查询出的单条结果集对应的java类型 [#{}]： 表示一个占位符? [#{id}]：表示该占位符待接收参数的名称为id。注意：如果参数为简单类型时，#{}里面的参数名称可以是任意定义 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; SELECT * FROM USER WHERE id = #{id} &lt;/select&gt; &lt;/mapper&gt; 加载映射文件//在SqlMapConfig.xml中，添加以下代码： &lt;!-- 加载mapper --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt; &lt;/mappers&gt; 编写测试程序//public class MybatisFirst { @Test public void findUserByIdTest() throws Exception{ //1、读取配置文件 String resource = &quot;SqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); //2、根据配置文件创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //3、SqlSessionFactory创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); //4、SqlSession执行statement，并返回映射结果 //第一个参数：statement的id，建议：namespace.statementId（确保唯一） //第二个参数：入参的值，它的类型要和映射文件中对应的statement的入参类型一致 User user = sqlSession.selectOne(&quot;findUserById&quot;, 1); //打印输出结果集 System.out.println(user); //5、关闭SqlSession sqlSession.close(); } } 根据用户名称来模糊查询用户信息列表编写映射文件//在User.xml中，添加以下内容 &lt;!-- 根据用户名称模糊查询用户信息列表 --&gt; &lt;!-- [${}]：表示拼接SQL字符串 [${value}]：表示要拼接的是简单类型参数。 注意： 1、如果参数为简单类型时，${}里面的参数名称必须为value 2、${}会引起SQL注入，一般情况下不推荐使用。但是有些场景必须使用${}，比如order by ${colname} --&gt; &lt;select id=&quot;findUsersByName&quot; parameterType=&quot;String&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; SELECT * FROM USER WHERE username LIKE &#39;%${value}%&#39; &lt;/select&gt; 加载映射文件//已配置，此处无需再次配置 编写测试程序//@Test public void findUsersByNameTest() throws Exception { // 1、读取配置文件 String resource = &quot;SqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); // 2、根据配置文件创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 3、SqlSessionFactory创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 4、SqlSession执行statement，并返回映射结果 // 第一个参数：statement的id，建议：namespace.statementId（确保唯一） // 第二个参数：入参的值，它的类型要和映射文件中对应的statement的入参类型一致 List&lt;User&gt; users = sqlSession.selectList(&quot;test.findUsersByName&quot;, &quot;小明&quot;); // 打印输出结果集 System.out.println(users); // 5、关闭SqlSession sqlSession.close(); } 添加用户编写映射文件//&lt;!-- 添加用户 --&gt; &lt;!-- 如果主键的值是通过MySQL自增机制生成的，那么我们此处不需要再显示的给ID赋值 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt; INSERT INTO USER(username,sex,birthday,address) VALUES (#{username},#{sex},#{birthday},#{address}) &lt;/insert&gt; 加载映射文件//已配置，此处无需再次配置 编写测试程序//注意：增删改操作要对SqlSession执行commit操作。 @Test public void insertUserTest() throws Exception { // 1、读取配置文件 String resource = &quot;SqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); // 2、根据配置文件创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); // 3、SqlSessionFactory创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 4、SqlSession执行statement，并返回映射结果 //构建user参数，没有赋值的属性采取默认值 User user = new User(); user.setUsername(&quot;东哥1&quot;); user.setAddress(&quot;清河宝盛西里&quot;); // 第一个参数：statement的id，建议：namespace.statementId（确保唯一） // 第二个参数：入参的值，它的类型要和映射文件中对应的statement的入参类型一致 sqlSession.insert(&quot;insertUser&quot;, user); //切记：增删改操作时，要执行commit操作 sqlSession.commit(); // 5、关闭SqlSession sqlSession.close(); } 主键返回之MySQL自增主键思路：MySQL自增主键，是指在insert之前MySQL会自动生成一个自增的主键。我们可以通过MySQL的函数获取到刚插入的自增主键:LAST_INSERT_ID()这个函数是在insert语句之后去调用。123456789101112131415//修改映射文件：&lt;!-- 添加用户之自增主键返回（selectKey方式） --&gt;&lt;!-- [selectKey标签]：通过select查询来生成主键 [keyProperty]：指定存放生成主键的属性 [resultType]：生成主键所对应的Java类型 [order]：指定该查询主键SQL语句的执行顺序，相对于insert语句 [last_insert_id]：MySQL的函数，要配合insert语句一起使用--&gt;&lt;insert id="insertUser" parameterType="cn.itcast.mybatis.po.User"&gt; &lt;selectKey keyProperty="id" resultType="int" order="AFTER"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO USER(username,sex,birthday,address) VALUES (#&#123;username&#125;,#&#123;sex&#125;,#&#123;birthday&#125;,#&#123;address&#125;)&lt;/insert&gt;主键返回之MySQL函数UUID// 注意：使用mysql的uuid()函数生成主键，需要修改表中id字段类型为string，长度设置成35位。 &lt;!-- 添加用户之UUID主键返回 --&gt; &lt;!-- [uuid]：MySQL的函数，生成的主键是35位的字符串，所以使用它时要修改id的类型为字符类型 注意： 1、此时order采用BEFORE，因为需要先生成出主键，再执行insert语句 2、显式的给ID赋值 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;string&quot; order=&quot;BEFORE&quot;&gt; SELECT UUID() &lt;/selectKey&gt; INSERT INTO USER(id,username,sex,birthday,address) VALUES (#{id},#{username},#{sex},#{birthday},#{address}) &lt;/insert&gt; 主键返回之Oracle序列返回//&lt;!-- 添加用户之sequence返回 --&gt; &lt;!-- 通过Oracle的sequence获取主键方式与MySQL的uuid方式基本一致 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt; SELECT user_seq.nextval() FROM dual &lt;/selectKey&gt; INSERT INTO USER(id,username,sex,birthday,address) VALUES (#{id},#{username},#{sex},#{birthday},#{address}) &lt;/insert&gt; 删除用户编写映射文件//&lt;!-- 根据ID删除用户 --&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; DELETE FROM USER WHERE id= #{id} &lt;/delete&gt; 加载映射文件//已配置，此处无需再次配置。 编写测试程序//@Test public void deleteUserTest() throws Exception{ // 1、读取配置文件 String resource = &quot;SqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); // 2、根据配置文件创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); // 3、SqlSessionFactory创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 4、SqlSession执行statement，并返回映射结果 // 第一个参数：statement的id，建议：namespace.statementId（确保唯一） // 第二个参数：入参的值，它的类型要和映射文件中对应的statement的入参类型一致 sqlSession.delete(&quot;test.deleteUser&quot;, 30); //切记：增删改操作时，要执行commit操作 sqlSession.commit(); // 5、关闭SqlSession sqlSession.close(); } 修改用户编写映射文件//&lt;!-- 根据传入的用户信息修改用户 --&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt; UPDATE USER SET username = #{username},sex=#{sex} WHERE id=#{id} &lt;/update&gt; 加载映射文件//已配置，此处无需再次配置。 编写测试程序//@Test public void updateUserTest() throws Exception{ // 1、读取配置文件 String resource = &quot;SqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); // 2、根据配置文件创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 3、SqlSessionFactory创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 4、SqlSession执行statement，并返回映射结果 //构建user参数，没有赋值的属性采取默认值 User user = new User(); user.setId(28); user.setUsername(&quot;东哥11&quot;); user.setAddress(&quot;清河宝盛西里&quot;); // 第一个参数：statement的id，建议：namespace.statementId（确保唯一） // 第二个参数：入参的值，它的类型要和映射文件中对应的statement的入参类型一致 sqlSession.update(&quot;test.updateUser&quot;, user); //切记：增删改操作时，要执行commit操作 sqlSession.commit(); // 5、关闭SqlSession sqlSession.close(); } 小结parameterType和resultTypeparameterType指定输入参数的java类型，可以填写别名或Java类的全限定名。resultType指定输出结果的java类型，可以填写别名或Java类的全限定名。#{}和${}{}：相当于预处理中的占位符？。{}里面的参数表示接收java输入参数的名称。{}可以接受HashMap、简单类型、POJO类型的参数。当接受简单类型的参数时，#{}里面可以是value，也可以是其他。{}可以防止SQL注入。${}：相当于拼接SQL串，对传入的值不做任何解释的原样输出。${}会引起SQL注入，所以要谨慎使用。${}可以接受HashMap、简单类型、POJO类型的参数。当接受简单类型的参数时，${}里面只能是value。selectOne和selectListselectOne：只能查询0或1条记录，大于1条记录的话，会报错；selectList：可以查询0或N条记录Mybatis开发dao&emsp;&emsp;Mybatis在项目中主要使用的地方就是开发dao（数据访问层），所以下面讲解一下mybatis开发dao的方法。有两种方式：原始dao开发方式、mapper代理开发方式（推荐）。需求根据用户ID来查询用户信息；根据用户名称来模糊查询用户信息列表；添加用户；原始dao开发方式思路程序员需要写dao接口和dao实现类。编程步骤根据需求创建po类编写全局配置文件根据需求编写映射文件加载映射文件编写dao接口编写dao实现类编写测试代码程序编写&emsp;&emsp;步骤中的1、2、3、4都在入门程序中进行了编写，此处不需要重新编写。开发dao接口//public interface UserDao { public User findUserById(int id);//根据用户ID来查询用户信息 public List&lt;User&gt; findUsersByName(String username);//根据用户名称来模糊查询用户信息列表 public void insertUser(User user);//添加用户 } 开发dao实现类SqlSession使用范围&emsp;&emsp;通过入门程序，大家可以看出，在测试代码中，有大量的重复代码。所以我们第一反应就是想给它抽取出共性的部分，但是SqlSession、SqlSessionFactory、SqlSessionFactoryBuilder有着各自的生命周期，因为这些生命周期的不同，抽取时要有针对性的处理。&emsp;&emsp;所以在抽取之前，我们先来了解并总结下它们三个的生命周期。SqlSessionFactoryBuilder&emsp;&emsp;它的作用只是通过配置文件创建SqlSessionFactory，所以只要创建出SqlSessionFactory，它就可以销毁了。所以说，它的生命周期是在方法之内。SqlSessionFactory&emsp;&emsp;它的作用是创建SqlSession的工厂，工厂一旦创建，除非应用停掉，不要销毁。所以说它的生命周期是在应用范围内。这里可以通过单例模式来管理它。&emsp;&emsp;在mybatis整合spring之后，最好的处理方式是把SqlSessionFactory交由spring来做单例管理。SqlSession&emsp;&emsp;SqlSession是一个面向用户（程序员）的接口，它的默认实现是DefaultSqlSession。&emsp;&emsp;Mybatis是通过SqlSession来操作数据库的。SqlSession中不仅包含要处理的SQL信息，还包括一些数据信息，所以说它是线程不安全的，因此它最佳的生命周期范围是在方法体之内。Dao实现类代码需要向dao实现类中注入SqlSessionFactory，在方法体内通过SqlSessionFactory创建SqlSession要注意SqlSession和SqlSessionFactory的生命周期。123456789101112131415161718192021222324252627 //public class UserDaoImpl implements UserDao &#123; //注入SqlSessionFactoryprivate SqlSessionFactory sqlSessionFactory;//使用构造方法来初始化SqlSessionFactorypublic UserDaoImpl(SqlSessionFactory sqlSessionFactory)&#123; this.sqlSessionFactory = sqlSessionFactory;&#125; @Overridepublic User findUserById(int id) &#123; //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全 SqlSession sqlSession = sqlSessionFactory.openSession(); //返回结果集 return sqlSession.selectOne("test.findUserById", id);&#125; @Overridepublic List&lt;User&gt; findUsersByName(String username) &#123; //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全 SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession.selectList("test.findUsersByName", username);&#125; @Overridepublic void insertUser(User user) &#123; //通过工厂，在方法内部获取SqlSession，这样就可以避免线程不安全 SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.insert("test.insertUser", user);&#125; &#125;编写测试代码//public class UserDaoTest { //声明全局的SqlSessionFactory private SqlSessionFactory sqlSessionFactory; @Before public void setUp() throws Exception { // 1、读取配置文件 String resource = &quot;SqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); // 2、根据配置文件创建SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } @Test public void testFindUserById() { //构造UserDao对象 UserDao userDao = new UserDaoImpl(sqlSessionFactory); //调用UserDao对象的方法 User user = userDao.findUserById(1); System.out.println(user); } @Test public void testFindUsersByName() { //构造UserDao对象 UserDao userDao = new UserDaoImpl(sqlSessionFactory); //调用UserDao对象的方法 List&lt;User&gt; list = userDao.findUsersByName(&quot;小明&quot;); System.out.println(list); } @Test public void testInsertUser() { //构造UserDao对象 UserDao userDao = new UserDaoImpl(sqlSessionFactory); //构造User对象 User user = new User(); user.setUsername(&quot;东哥3&quot;); user.setAddress(&quot;清河宝盛西里3&quot;); //调用UserDao对象的方法 userDao.insertUser(user); System.out.println(user.getId()); } } 问题总结&emsp;原始dao开发存在一些问题：存在一定量的模板代码。比如：通过SqlSessionFactory创建SqlSession；调用SqlSession的方法操作数据库；关闭Sqlsession。存在一些硬编码。调用SqlSession的方法操作数据库时，需要指定statement的id，这里存在了硬编码。Mapper代理开发方式（推荐）&emsp;&emsp;Mapper代理的开发方式，程序员只需要编写mapper接口（相当于dao接口）即可。Mybatis会自动的为mapper接口生成动态代理实现类。&emsp;&emsp;不过要实现mapper代理的开发方式，需要遵循一些开发规范。开发规范mapper接口的全限定名要和mapper映射文件的namespace的值相同。mapper接口的方法名称要和mapper映射文件中的statement的id相同；3.mapper接口的方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致。mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致；&emsp;注：通过规范式的开发mapper接口，可以解决原始dao开发当中存在的问题：模板代码已经去掉；剩下去不掉的操作数据库的代码，其实就是一行代码。这行代码中硬编码的部分，通过第一和第二个规范就可以解决。编程步骤根据需求创建po类编写全局配置文件根据需求编写映射文件加载映射文件编写mapper接口编写测试代码程序编写&emsp;&emsp;步骤中的1、2都在入门程序中进行了编写，此处不需要重新编写。编写mapper映射文件&emsp;&emsp;重新定义mapper映射文件UserMapper.xml（内容同Users.xml，除了namespace的值），放到新创建的目录mapper下。//&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- namespace：此时用mapper代理方式，它的值必须等于对应mapper接口的全限定名 --&gt; &lt;mapper namespace=&quot;cn.itcast.mybatis.mapper.UserMapper&quot;&gt; &lt;!-- 根据用户ID，查询用户信息 --&gt; &lt;!-- [id]：statement的id，要求在命名空间内唯一 [parameterType]：入参的java类型，可是是简单类型、POJO、HashMap [resultType]：查询出的单条结果集对应的java类型 [#{}]： 表示一个占位符? [#{id}]：表示该占位符待接收参数的名称为id。注意：如果参数为简单类型时，#{}里面的参数名称可以是任意定义 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; SELECT * FROM USER WHERE id = #{id} &lt;/select&gt; &lt;!-- 根据用户名称模糊查询用户信息列表 --&gt; &lt;!-- [${}]：表示拼接SQL字符串，即不加解释的原样输出 [${value}]：表示要拼接的是简单类型参数。 注意： 1、如果参数为简单类型时，${}里面的参数名称必须为value 2、${}会引起SQL注入，一般情况下不推荐使用。但是有些场景必须使用${}，比如order by ${colname} --&gt; &lt;select id=&quot;findUsersByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; SELECT * FROM USER WHERE username LIKE &#39;%${value}%&#39; &lt;/select&gt; &lt;!-- 添加用户之自增主键返回（selectKey方式） --&gt; &lt;!-- [selectKey标签]：通过select查询来生成主键 [keyProperty]：指定存放生成主键的属性 [resultType]：生成主键所对应的Java类型 [order]：指定该查询主键SQL语句的执行顺序，相对于insert语句，此时选用AFTER [last_insert_id]：MySQL的函数，要配合insert语句一起使用 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO USER(username,sex,birthday,address) VALUES (#{username},#{sex},#{birthday},#{address}) &lt;/insert&gt; &lt;/mapper&gt; 加载mapper映射文件//&lt;!-- 加载mapper --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; 编写mapper接口&emsp;&emsp;内容同UserDao接口一样：//public interface UserMapper { //根据用户ID来查询用户信息 public User findUserById(int id); //根据用户名称来模糊查询用户信息列表 public List&lt;User&gt; findUsersByName(String username); //添加用户 public void insertUser(User user); } 编写测试代码//public class UserMapperTest { // 声明全局的SqlSessionFactory private SqlSessionFactory sqlSessionFactory; @Before public void setUp() throws Exception { // 1、读取配置文件 String resource = &quot;SqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); // 2、根据配置文件创建SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } @Test public void testFindUserById() { // 创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession，获取mapper接口的动态代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 调用mapper对象的方法 User user = userMapper.findUserById(1); System.out.println(user); // 关闭SqlSession sqlSession.close(); } @Test public void testFindUsersByName() { // 创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession，获取mapper接口的动态代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 调用mapper对象的方法 List&lt;User&gt; list = userMapper.findUsersByName(&quot;小明&quot;); System.out.println(list); // 关闭SqlSession sqlSession.close(); } @Test public void testInsertUser() { // 创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession，获取mapper接口的动态代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //构造User对象 User user = new User(); user.setUsername(&quot;东哥4&quot;); user.setAddress(&quot;清河宝盛西里4&quot;); // 调用mapper对象的方法 userMapper.insertUser(user); System.out.println(user.getId()); //执行SqlSession的commit操作 sqlSession.commit(); // 关闭SqlSession sqlSession.close(); } } Mybatis全局配置文件&emsp;&emsp;SqlMapConfig.xml是mybatis的全局配置文件，它的名称可以是任意命名的。全部配置内容&emsp;SqlMapConfig.xml的配置内容和顺序如下（顺序不能乱）：Properties（属性）Settings（全局参数设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境信息集合）environment（单个环境信息）transactionManager（事物）dataSource（数据源）mappers（映射器）常用配置详解Properties&emsp;SqlMapConfig.xml文件中可以引用java属性文件中的配置信息&emsp;&emsp;db.properties配置信息如下：//db.driver=com.mysql.jdbc.Driver db.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf8 db.username=root db.password=root SqlMapConfig.xml使用properties标签后，如下所示：//&lt;!-- 通过properties标签，读取java配置文件的内容 --&gt; &lt;properties resource=&quot;db.properties&quot; /&gt; &lt;!-- 配置mybatis的环境信息 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源，采用dbcp连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${db.driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${db.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${db.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${db.password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &emsp;使用${}，可以引用已经加载的java配置文件中的信息。&emsp;&emsp;注意：mybatis将按照下面的顺序加载属性：Properties标签体内定义的属性首先被读取Properties引用的属性会被读取，如果发现上面已经有同名的属性了，那后面会覆盖前面的值parameterType接收的值会最后被读取，如果发现上面已经有同名的属性了，那后面会覆盖前面的值&emsp;所以说，mybatis读取属性的顺序由高到低分别是：parameterType接收的属性值、properties引用的属性、properties标签内定义的属性。Settings&emsp;&emsp;mybatis全局配置参数，全局参数将会影响mybatis的运行行为。详细如下：typeAliases&emsp;&emsp;别名是使用是为了在映射文件中，更方便的去指定入参和结果集的类型，不再用写很长的一段全限定名。mybatis支持的别名别名映射的类型_bytebyte_longlong_shortshort_intint_integerint_doubledouble_floatfloat_booleanbooleanstringStringbyteBytelongLongshortShortintIntegerintegerIntegerdoubleDoublefloatFloatbooleanBooleandateDatedecimalBigDecimalbigdecimalBigDecimal自定义别名&emsp;&emsp;SqlMapConfig.xml配置信息如下：//&lt;!-- 定义别名 --&gt; &lt;typeAliases&gt; &lt;!-- 单个定义别名 --&gt; &lt;typeAlias type=&quot;cn.itcast.mybatis.po.User&quot; alias=&quot;user&quot;/&gt; &lt;!-- 批量定义别名（推荐） --&gt; &lt;!-- [name]：指定批量定义别名的类包，别名为类名（首字母大小写都可） --&gt; &lt;package name=&quot;cn.itcast.mybatis.po&quot;/&gt; &lt;/typeAliases&gt; mappers&lt;mapper resource=’’/&gt;&emsp;&emsp;使用相对于类路径的资源&emsp;&emsp;&emsp;如：&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt;&lt;mapper url=’’/&gt;&emsp;&emsp;使用完全限定路径如：&emsp;&emsp;&emsp;&lt;mapper url=&quot;file:///D:\workspace_spingmvc\mybatis_01\config\sqlmap\User.xml&quot; /&gt;&lt;mapper class=’’/&gt;&emsp;&emsp;使用mapper接口的全限定名&emsp;&emsp;&emsp;如：&lt;mapper class=&quot;cn.itcast.mybatis.mapper.UserMapper&quot;/&gt;注意：此种方法要求mapper接口和mapper映射文件要名称相同，且放到同一个目录下;```（推荐）&emsp;&emsp;注册指定包下的所有映射文件&emsp;&emsp;&emsp;如：&lt;package name=&quot;cn.itcast.mybatis.mapper&quot;/&gt;注意：此种方法要求mapper接口和mapper映射文件要名称相同，且放到同一个目录下;Mybatis映射文件（核心）输入映射ParameterType&emsp;&emsp;指定输入参数的java类型，可以使用别名或者类的全限定名。它可以接收简单类型、POJO、HashMap。传递简单类型&emsp;&emsp;参考入门需求：根据用户ID查询用户信息。传递POJO对象&emsp;&emsp;参考入门需求：添加用户。传递POJO包装对象&emsp;&emsp;开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。需求&emsp;&emsp;综合查询用户信息，需要传入查询条件复杂，比如（用户信息、订单信息、商品信息）。定义包装对象&emsp;&emsp;一般User.java类要和数据表表字段一致，最好不要在这里面添加其他字段，学习mybatis的逆向工程时，会根据表结构，生成po类，如果在po类中扩展字段，此时会被覆盖掉。&emsp;&emsp;所以针对要扩展的po类，我们需要创建一个扩展类，来继承它。&emsp;&emsp;定义POJO包装类：编写Mapper接口//通过包装类来进行复杂的用户信息综合查询 public List&lt;UserExt&gt; findUserList(UserQueryVO userQueryVO); 编写mapper映射文件&lt;!-- 通过包装类来进行复杂的用户信息综合查询 --&gt; &lt;select id=_&quot;findUserList&quot;_ parameterType=_&quot;userQueryVO&quot;_ resultType=_&quot;userExt&quot;_&gt; SELECT * FROM USER WHERE sex=#{userExt.sex} AND username LIKE &#39;%${userExt.username}%&#39; &lt;/select&gt; 注意：入参的类型变为UserQueryVO、结果集的类型变为UserExt，#{}里面的参数变为UserQueryVO对象中的userExt属性的sex和username子属性。编写测试代码//@Test public void findUserListTest() { // 创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession，获取mapper接口的动态代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //构造userQueryVO对象 UserQueryVO userQueryVO = new UserQueryVO(); // 构造UserExt对象 UserExt userExt = new UserExt(); userExt.setSex(&quot;1&quot;); userExt.setUsername(&quot;小明&quot;); userQueryVO.setUserExt(userExt); // 调用mapper对象的方法 List&lt;UserExt&gt; list = userMapper.findUserList(userQueryVO); System.out.println(list); // 关闭SqlSession sqlSession.close(); } 传递HashMap（练习）同传递POJO对象一样，map的key相当于pojo的属性。映射文件&lt;!-- 传递hashmap综合查询用户信息 --&gt; &lt;select id=&quot;findUserByHashmap&quot; parameterType=&quot;hashmap&quot; resultType=&quot;user&quot;&gt; select * from user where id=#{id} and username like &#39;%${username}%&#39; &lt;/select&gt; &emsp;&emsp; 上边引用的是hashmap的key。测试代码Public void testFindUserByHashmap()throws Exception{ //获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //构造查询条件Hashmap对象 HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;id&quot;, 1); map.put(&quot;username&quot;, &quot;管理员&quot;); //传递Hashmap对象查询用户列表 List&lt;User&gt;list = userMapper.findUserByHashmap(map); //关闭session session.close(); } &emsp;异常测试：传递的map中的key和sql中解析的key不一致。测试结果没有报错，只是通过key获取值为空。输出映射resultType&emsp;&emsp;先看下原先resultType作为输出结果映射时，它的特点，如何再把列名改为别名，看看是否还能不能映射成功。使用方法使用resultType进行结果映射时，查询的列名和映射的pojo属性名完全一致，该列才能映射成功。如果查询的列名和映射的pojo属性名全部不一致，则不会创建pojo对象；如果查询的列名和映射的pojo属性名有一个一致，就会创建pojo对象。输出简单类型&emsp;&emsp;当输出结果只有一列时，可以使用ResultType指定简单类型作为输出结果类型。需求&emsp;&emsp;综合查询用户总数，需要传入查询条件复杂，比如（用户信息、订单信息、商品信息）。Mapper映射文件&lt;!-- 综合查询用户信息总数，需要传入查询条件复杂，比如（用户信息、订单信息、商品信息） --&gt; &lt;select id=&quot;findUsersCount&quot; parameterType=&quot;UserQueryVO&quot; resultType=&quot;int&quot;&gt; SELECT count(1) FROM USER WHERE sex = #{userExt.sex} AND username LIKE &#39;%${userExt.username}%&#39; &lt;/select&gt; Mapper接口//综合查询用户信息总数。学习：resultType输出简单类型 public int findUsersCount(UserQueryVO vo); 测试代码//@Test public void testFindUsersCount() { // 创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession，获取mapper接口的动态代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //构造userQueryVO对象 UserQueryVO userQueryVO = new UserQueryVO(); // 构造UserExt对象 UserExt userExt = new UserExt(); userExt.setSex(&quot;1&quot;); userExt.setUsername(&quot;小明&quot;); userQueryVO.setUserExt(userExt); int count = mapper.findUsersCount(userQueryVO); System.out.println(count); // 关闭SqlSession sqlSession.close(); } 输出POJO单个对象和列表&emsp;注意：输出单个pojo对象和pojo列表（盛放pojo对象）时，mapper映射文件中的resultType的类型是一样的，mapper接口的方法返回值不同。Mapper映射文件&emsp;&emsp;Mapper映射文件是同一个&lt;select id=&quot;findUsersByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; SELECT * FROM USER WHERE username LIKE &#39;%${value}%&#39; &lt;/select&gt; Mapper接口&emsp;&emsp;下面看下mapper接口的不同之处输出单个pojo对象12 //根据用户名称来模糊查询用户信息 public User findUsersByName(String username);输出pojo列表12//根据用户名称来模糊查询用户信息列表 public List&lt;User&gt; findUsersByName(String username);总结：同样的mapper映射文件，返回单个对象和对象列表时，mapper接口在生成动态代理的时候，会根据返回值的类型，决定调用selectOne方法还是selectList方法。resultMap&emsp;&emsp;resultMap可以进行高级结果映射（一对一、一对多映射）。使用方法&emsp;&emsp;如果查询出来的列名和属性名不一致，通过定义一个resultMap将列名和pojo属性名之间作一个映射关系。定义resultMap使用resultMap作为statement的输出映射类型。需求&emsp;&emsp;把下面SQL的输出结果集进行映射SELECT id id_,username username_,sex sex_ FROM USER WHERE id = 1 Mapper映射文件&emsp;&emsp;定义resultMap：&lt;!-- 定义resultMap --&gt; &lt;!-- [id]：定义resultMap的唯一标识 [type]：定义该resultMap最终映射的pojo对象 [id标签]：映射结果集的唯一标识列，如果是多个字段联合唯一，则定义多个id标签 [result标签]：映射结果集的普通列 [column]：SQL查询的列名，如果列有别名，则该处填写别名 [property]：pojo对象的属性名 --&gt; &lt;resultMap type=&quot;user&quot; id=&quot;userResultMap&quot;&gt; &lt;id column=&quot;id_&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username_&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;sex_&quot; property=&quot;sex&quot;/&gt; &lt;/resultMap&gt; &emsp;&emsp;定义statement：&lt;!-- 根据ID查询用户信息（学习resultMap） --&gt; &lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt; SELECT id id_,username username_,sex sex_ FROM USER WHERE id = #{id} &lt;/select&gt; Mapper接口定义 //根据ID查询用户信息（学习resultMap） public User findUserByIdResultMap(int id); 定义Statement使用resultMap映射结果集时，Mapper接口定义方法的返回值类型为mapper映射文件中resultMap的type类型。测试代码@Test public void findUserByIdResultMapTest() { // 创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession，获取mapper接口的动态代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 调用mapper对象的方法 User user = userMapper.findUserByIdResultMap(1); System._out_.println(user); // 关闭SqlSession sqlSession.close(); 动态SQL（重点）&emsp;&emsp;通过Mybatis提供的各种动态标签实现动态拼接sql，使得mapper映射文件在编写SQL时更加灵活，方便。常用动态SQL标签有：if、where、foreach；If和whereIf标签：作为判断入参来使用的，如果符合条件，则把if标签体内的SQL拼接上。注意：用if进行判断是否为空时，不仅要判断null，也要判断空字符串‘’；Where标签：会去掉条件中的第一个and符号。需求&emsp;&emsp;用户信息综合查询列表和用户信息综合查询总数这两个statement的定义使用动态SQL。映射文件&lt;!-- 综合查询用户信息，需要传入查询条件复杂，比如（用户信息、订单信息、商品信息） --&gt; &lt;select id=&quot;findUsersByQueryVO&quot; parameterType=&quot;cn.itcast.mybatis.po.QueryUserVO&quot; resultType=&quot;User&quot;&gt; SELECT * FROM USER &lt;where&gt; &lt;if test=&quot;userExt != null&quot;&gt; &lt;if test=&quot;userExt.sex != null and userExt.sex != &#39;&#39;&quot;&gt; AND sex = #{userExt.sex} &lt;/if&gt; &lt;if test=&quot;userExt.username != null and userExt.username != &#39;&#39;&quot;&gt; AND username LIKE &#39;%${userExt.username}%&#39; &lt;/if&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 综合查询用户信息总数，需要传入查询条件复杂，比如（用户信息、订单信息、商品信息） --&gt; &lt;select id=&quot;findUsersCount&quot; parameterType=&quot;QueryUserVO&quot; resultType=&quot;int&quot;&gt; SELECT count(1) FROM USER &lt;where&gt; &lt;if test=&quot;userExt != null&quot;&gt; &lt;if test=&quot;userExt.sex != null and userExt.sex != &#39;&#39;&quot;&gt; AND sex = #{userExt.sex} &lt;/if&gt; &lt;if test=&quot;userExt.username != null and userExt.username != &#39;&#39;&quot;&gt; AND username LIKE &#39;%${userExt.username}%&#39; &lt;/if&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; Mapper接口//通过包装类来进行复杂的用户信息综合查询 public List&lt;UserExt&gt; findUserList(UserQueryVO userQueryVO); //综合查询用户总数 public int findUsersCount(UserQueryVO userQueryVO); 测试代码&emsp;&emsp;不传用户名：&emsp;&emsp;输出的SQL如下（也不包含用户名）：&emsp;通过测试可以得知，打印出的SQL语句确实会随着条件的满足情况而不一样。SQL片段&emsp;&emsp;Mybatis提供了SQL片段的功能，可以提高SQL的可重用性。定义SQL片段&emsp;&emsp;使用sql标签来定义一个SQL片段：//&lt;!-- 定义SQL片段 --&gt; &lt;!-- [sql标签]：定义一个SQL片段 [id]：SQL片段的唯一标识 建议： 1、SQL片段中的内容最好是以单表来定义 2、如果是查询字段，则不要写上SELECT 3、如果是条件语句，则不要写上WHERE --&gt; &lt;sql id=_&quot;select_user_where&quot;_&gt; &lt;if test=_&quot;userExt != null&quot;_&gt; &lt;if test=_&quot;userExt.sex != null and userExt.sex != &#39;&#39;&quot;_&gt; AND sex = #{userExt.sex} &lt;/if&gt; &lt;if test=_&quot;userExt.username != null and userExt.username != &#39;&#39;&quot;_&gt; AND username LIKE &#39;%${userExt.username}%&#39; &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt; 引用SQL片段&emsp;&emsp;使用&lt;include refid=’’ /&gt; 来引用SQL片段：//&lt;!-- 根据用户id来查询用户信息（使用SQL片段） --&gt; &lt;!-- [include标签]：引用已经定义好的SQL片段 [refid]：引用的SQL片段id --&gt; &lt;select id=_&quot;findUserList&quot;_ parameterType=_&quot;userQueryVO&quot;_ resultType=_&quot;userExt&quot;_&gt; SELECT * FROM USER &lt;where&gt; &lt;include refid=_&quot;select_user_where&quot;_/&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 综合查询用户信息总数，需要传入查询条件复杂，比如（用户信息、订单信息、商品信息） --&gt; &lt;select id=_&quot;findUsersCount&quot;_ parameterType=_&quot;QueryUserVO&quot;_ resultType=_&quot;int&quot;_&gt; SELECT count(1) FROM USER &lt;where&gt; &lt;include refid=_&quot;select_user_where&quot;_/&gt; &lt;/where&gt; &lt;/select&gt; Foreach&emsp;&emsp;向sql传递数组或List时，mybatis使用foreach解析数组里的参数并拼接到SQL中。传递pojo对象中的List集合需求&emsp;&emsp;在用户查询列表和查询总数的statement中增加多个id输入查询。SQLSELECT * FROM user WHERE id IN (1,10,16)定义pojo中的List属性映射文件//&lt;!-- [foreach标签]：表示一个foreach循环 --&gt; &lt;!-- [collection]：集合参数的名称，如果是直接传入集合参数，则该处的参数名称只能填写[list]。 --&gt; &lt;!-- [item]：每次遍历出来的对象 --&gt; &lt;!-- [open]：开始遍历时拼接的串 --&gt; &lt;!-- [close]：结束遍历时拼接的串 --&gt; &lt;!-- [separator]：遍历出的每个对象之间需要拼接的字符 --&gt; &lt;if test=_&quot;idList != null and idList.size &gt; 0&quot;_&gt; &lt;foreach collection=_&quot;idList&quot;_ item=_&quot;id&quot;_ open=_&quot;AND id IN (&quot;_ close=_&quot;)&quot;_ separator=_&quot;,&quot;_&gt; #{id} &lt;/foreach&gt; &lt;/if&gt; Mapper接口&emsp;&emsp;根据用户ID的集合查询用户列表（学习foreach标签之通过POJO对象传ID集合）public List&lt;UserExt&gt; findUserList(UserQueryVO vo);测试代码//@Test public void testFindUserList() { // 创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession，获取mapper接口的动态代理对象 UserMapper mapper = sqlSession.getMapper(UserMapper.class); // 构造QueryUserVO对象 QueryUserVO vo = new QueryUserVO(); // UserExt ext = new UserExt(); // ext.setUsername(&quot;小明&quot;); // ext.setSex(&quot;1&quot;); // vo.setUserExt(ext); // 创建用户ID集合，然后设置到QueryUserVO对象中 List&lt;Integer&gt; idList = new ArrayList&lt;Integer&gt;(); idList.add(1); idList.add(10); idList.add(16); vo.setIdList(idList); // 调用mapper代理对象的方法 List&lt;UserExt&gt; list = mapper.findUserList(vo); System._out_.println(list); // 关闭SqlSession sqlSession.close(); } 直接传递List集合需求&emsp;&emsp;根据用户ID的集合查询用户列表SQLSELECT * FROM user WHERE id IN (1,10,16)映射文件//&lt;!-- 根据用户ID的集合查询用户列表（学习foreach标签之直接传ID集合） --&gt; &lt;!-- [foreach标签]：表示一个foreach循环 [collection]：集合参数的名称，如果是直接传入集合参数，则该处的参数名称只能填写[list]。 [item]：定义遍历集合之后的参数名称 [open]：开始遍历之前需要拼接的SQL串 [close]：结束遍历之后需要拼接的SQL串 [separator]：遍历出的每个对象之间需要拼接的字符 --&gt; &lt;select id=&quot;findUsersByIdList&quot; parameterType=&quot;java.util.List&quot; resultType=&quot;user&quot;&gt; SELECT * FROM USER &lt;where&gt; &lt;if test=&quot;list!= null and list.size &gt; 0&quot;&gt; &lt;foreach collection=&quot;list&quot; item=&quot;id&quot; open=&quot;AND id IN (&quot; close=&quot;)&quot;_separator=&quot;,&quot;&gt; #{id} &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; Mapper接口//根据用户ID的集合查询用户列表（学习foreach标签之直接传ID集合) public List&lt;User&gt; findUsersByIdList (List&lt;Integer&gt; idList); 测试代码//@Test public void findUsersByIdListTest() { // 创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession，获取mapper接口的动态代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 构造List&lt;Integer&gt;集合 List&lt;Integer&gt; idList = new ArrayList&lt;Integer&gt;(); idList.add(1); idList.add(10); idList.add(16); // 调用mapper对象的方法 List&lt;User&gt; list = userMapper.findUsersByIdList (idList); System.out.println(list); // 关闭SqlSession sqlSession.close(); } mybatis与hibernate的区别及各自应用场景&emsp;Mybatis技术特点：通过直接编写SQL语句，可以直接对SQL进行性能的优化；学习门槛低，学习成本低。只要有SQL基础，就可以学习mybatis，而且很容易上手；由于直接编写SQL语句，所以灵活多变，代码维护性更好。不能支持数据库无关性，即数据库发生变更，要写多套代码进行支持，移植性不好。需要编写结果映射。&emsp;Hibernate技术特点：标准的orm框架，程序员不需要编写SQL语句。具有良好的数据库无关性，即数据库发生变化的话，代码无需再次编写。学习门槛高，需要对数据关系模型有良好的基础，而且在设置OR映射的时候，需要考虑好性能和对象模型的权衡。程序员不能自主的去进行SQL性能优化。&emsp;Mybatis应用场景：&emsp;&emsp;需求多变的互联网项目，例如电商项目。&emsp;Hibernate应用场景：&emsp;&emsp;需求明确、业务固定的项目，例如OA项目、ERP项目等。关联查询映射分析数据模型思路每张表记录的数据内容&emsp;&emsp;分模块对每张表记录的内容进行熟悉，相当于你学习系统需求（功能）的过程。每张表重要的字段&emsp;&emsp;主键、外键、非空字段数据库级别表与表的关系&emsp;&emsp;外键关系表与表之间的业务关系&emsp;&emsp;在分析表与表之间的业务关系时一定要建立 在某个业务意义基础上去分析。&emsp;&emsp;图形分析:数据库表之间有外键关系的业务关系user和orders：&emsp;&emsp;user——&gt;orders：一个用户可以创建多个订单，一对多&emsp;&emsp;orders—-&gt;user：一个订单只由一个用户创建，一对一orders和orderdetail：&emsp;&emsp;orders—-&gt;orderdetail：一个订单可以包括 多个订单明细，因为一个订单可以购买多个商品，每个商品的购买信息在orderdetail记录，一对多关系&emsp;&emsp;orderdetail—&gt; orders：一个订单明细只能包括在一个订单中，一对一orderdetail和itesm：&emsp;&emsp;orderdetail—-&gt;itesms：一个订单明细只对应一个商品信息，一对一&emsp;&emsp;items—-&gt; orderdetail:一个商品可以包括在多个订单明细 ，一对多数据库表之间没有外键关系的业务关系Orders和items：//这两张表没有直接的外键关系，通过业务及数据库的间接关系分析出它们是多对多的关系。&emsp;&emsp;Orders—-&gt; orderdetai—-&gt;items：一个订单可以有多个订单明细，一个订单明细对应一个商品，所以一个订单对应多个商品&emsp;&emsp;Items—-&gt;orderdetail—-&gt;orders：一个商品可以对应多个订单明细，一个订单明细对应一个订单，所以一个商品对应多个订单User和items：//这两张表没有直接的外键关系，通过业务及数据库的间接关系分析出它们是多对多的关系。&emsp;&emsp;User—-&gt;orders—-&gt;orderdetail—-&gt;items：一个用户有多个订单，一个订单有多个订单明细、一个订单明细对应一个商品，所以一个用户对应多个商品&emsp;&emsp;Items—-&gt;orderdetail—-&gt;orders—-&gt;user：一个商品对应多个订单明细，一个订单明细对应一个订单，一个订单对应一个用户，所以一个商品对应多个用户一对一查询需求&emsp;&emsp;查询订单信息，关联查询创建订单的用户信息SQL语句&emsp;&emsp;确定查询的主表：订单表&emsp;&emsp;确定查询的关联表：用户表&emsp;&emsp;关联查询使用内链接？还是外链接？//Select Orders.id, Orders.user_id, orders.number, orders.createtime, orders.note, user.username, user.address from orders,user where orders.user_id = user.id resultType&emsp;&emsp;复杂查询时，单表对应的po类已不能满足输出结果集的映射。所以要根据需求建立一个扩展类来作为resultType的类型。创建po类//通过此类映射订单和用户查询的结果，让此类继承包括 字段较多的pojo类 public class OrdersExt extends Orders{ //添加用户属性 /*USER.username, USER.address */ private String username; private String address; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } 编写mapper接口&emsp;&emsp;创建OrdersMapper接口类，在类中添加以下内容：// 进行订单信息查询，包括用户的名称和地址信息 public List&lt;OrdersExt&gt; findOrdersUser(); 编写映射文件//&lt;mapper namespace=&quot;cn.itcast.mybatis.mapper.OrdersMapper&quot;&gt; &lt;!-- 定义查询订单表列名的SQL片段 --&gt; &lt;sql id=&quot;select_orders&quot;&gt; Orders.id, Orders.user_id, orders.number, orders.createtime, orders.note &lt;/sql&gt; &lt;!-- 定义查询用户表列名的SQL片段 --&gt; &lt;sql id=&quot;select_user&quot;&gt; user.username, user.address &lt;/sql&gt; &lt;!-- 进行订单信息查询，包括用户的名称和地址信息 --&gt; &lt;select id=&quot;findOrdersUser&quot; resultType=&quot;OrdersExt&quot;&gt; Select &lt;include refid=&quot;select_orders&quot; /&gt; &lt;include refid=&quot;select_user&quot;&gt;&lt;/include&gt; from orders,user where orders.user_id = user.id &lt;/select&gt; &lt;/mapper&gt; 加载映射文件//&lt;!-- 批量加载mapper文件，需要mapper接口文件和mapper映射文件名称相同且在同一个包下 --&gt; &lt;package name=&quot;cn.itcast.mybatis.mapper&quot;/&gt; 编写测试代码//@Test public void testFindOrdersUser() { // 创建sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession构造usermapper的代理对象 OrdersMapper ordersMapper = sqlSession.getMapper(OrdersMapper.class); // 调用usermapper的方法 List&lt;OrdersExt&gt; list = ordersMapper.findOrdersUser(); System.out.println(list); // 释放SqlSession sqlSession.close(); } resultMap修改po类&emsp;&emsp;在Orders类中，添加User对象//public class Orders { private Integer id; private Integer userId; private String number; private Date createtime; private String note; //用户信息 private User user; 编写mapper接口 // 进行订单信息查询，包括用户的名称和地址信息（resultMap） public List&lt;OrdersExt&gt; findOrdersUserRstMap(); 编写映射文件//&lt;!-- 进行订单信息查询，包括用户的名称和地址信息 (ResultMap) --&gt; &lt;select id=&quot;findOrdersUserRstMap&quot; resultMap=&quot;OrdersUserRstMap&quot;&gt; Select &lt;include refid=&quot;select_orders&quot; /&gt; , &lt;include refid=&quot;select_user&quot;&gt;&lt;/include&gt; from orders,user where orders.user_id = user.id &lt;/select&gt; &lt;!-- 定义orderUserResultMap --&gt; &lt;resultMap type=&quot; cn.itcast.mybatis.po.Orders&quot; id=&quot;OrdersUserRstMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;number&quot; property=&quot;number&quot; /&gt; &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot; /&gt; &lt;result column=&quot;note&quot; property=&quot;note&quot; /&gt; &lt;!-- 映射一对一关联关系的用户对象--&gt; &lt;!-- property：指定关联对象要映射到Orders的哪个属性上 javaType：指定关联对象所要映射的java类型 --&gt; &lt;!-- id标签：指定关联对象结果集的唯一标识，很重要，不写不会报错，但是会影响性能 --&gt; &lt;association property=&quot;user&quot; javaType=&quot;cn.itcast.mybatis.po.User&quot;&gt; &lt;id column=&quot;user_id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot; /&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot; /&gt; &lt;/association&gt; &lt;/resultMap&gt; 编写测试代码//@Test public void testFindOrdersUserRstMap() { // 创建sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession构造usermapper的代理对象 OrdersMapper ordersMapper = sqlSession.getMapper(OrdersMapper.class); // 调用usermapper的方法 List&lt;Orders&gt; list = ordersMapper.findOrdersUserRstMap(); //此处我们采用debug模式来跟踪代码，然后验证结果集是否正确 System.out.println(list); // 释放SqlSession sqlSession.close(); } 一对一小结实现一对一查询：resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的对象属性中。resultMap可以实现延迟加载，resultType无法实现延迟加载。一对多查询&emsp;&emsp;一对多查询和一对一查询的配置基本类似。只是如果使用resultMap的话，映射一对多关联关系要使用collection标签。需求&emsp;&emsp;查询订单信息及订单明细信息SQL语句&emsp;&emsp;确定主查询表：订单表&emsp;&emsp;确定关联查询表：订单明细表&emsp;&emsp;在一对一查询基础上添加订单明细表关联即可。//Select Orders.id, Orders.user_id, orders.number, orders.createtime, orders.note, user.username, user.address, orderdetail.id detail_id, orderdetail.items_id, orderdetail.items_num from orders,user,orderdetail where orders.user_id = user.id and orders.id = orderdetail.orders_id 分析&emsp;&emsp;使用resultType将上边的 查询结果映射到pojo中，订单信息将会重复。&emsp;要求：&emsp;&emsp;对orders映射不能出现重复记录。在orders.java类中添加ListdetailList属性。最终会将订单信息映射到orders中，订单所对应的订单明细映射到orders中的detailList属性中。映射成的orders记录数为两条（orders信息不重复）,每个orders中的detailList属性存储了该订单所对应的订单明细集合。修改PO类&emsp;&emsp;在Orders类中添加以下属性，并提供get/set方法：//订单明细 private List&lt;Orderdetail&gt; detailList; 编写mapper接口// 查询订单信息及订单明细信息（一对多映射之使用resultMap） public List&lt;Orders&gt; findOrdersAndOrderdetailRstMap(); 编写映射文件//&lt;!-- 定义OrdersAndOrderdetailRstMap --&gt; &lt;!-- extends：继承已有的ResultMap，值为继承的ResultMap的唯一标示 --&gt; &lt;resultMap type=&quot;Orders&quot; id=&quot;OrdersAndOrderdetailRstMap&quot; extends=&quot;OrdersUserRstMap&quot;&gt; &lt;!-- 映射关联关系（一对多） --&gt; &lt;!-- collection标签：定义一个一对多关系 ofType：指定该集合参数所映射的类型 --&gt; &lt;collection property=&quot;detailList&quot; ofType=&quot;Orderdetail&quot;&gt; &lt;id column=&quot;detail_id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot; /&gt; &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot; /&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询订单信息，包括用户名称、用户地址，订单商品信息（嵌套结果） --&gt; &lt;select id=&quot;findOrdersAndOrderdetailRstMap&quot; resultMap=&quot;OrdersAndOrderdetailRstMap&quot;&gt; Select &lt;include refid=&quot;select_orders&quot; /&gt; , &lt;include refid=&quot;select_user&quot;/&gt; , orderdetail.id detail_id, orderdetail.items_id, orderdetail.items_num from orders,user,orderdetail where orders.user_id = user.id and orders.id = orderdetail.orders_id &lt;/select&gt; &emsp;&emsp;resultMap的extends属性：可以用此属性来继承一个已有的resultmap。但是它继承的resultMap的type和它本身的type要保持一致。编写测试代码//@Test public void testFindOrdersAndOrderdetailRstMap() { // 创建sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession构造usermapper的代理对象 OrdersMapper ordersMapper = sqlSession.getMapper(OrdersMapper.class); // 调用usermapper的方法 List&lt;Orders&gt; list = ordersMapper.findOrdersAndOrderdetailRstMap(); //此处我们采用debug模式来跟踪代码，然后验证结果集是否正确 System.out.println(list); // 释放SqlSession sqlSession.close(); } 一对多小结&emsp;&emsp;mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。使用resultType实现：需要对结果集进行二次处理。将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中。多对多查询需求&emsp;&emsp;查询用户信息及用户购买的商品信息，要求将关联信息映射到主pojo的pojo属性中SQL语句&emsp;&emsp;查询主表：user&emsp;&emsp;查询关联表：orders、orderdetail、items//Select Orders.id, Orders.user_id, orders.number, orders.createtime, orders.note, user.username, user.address, orderdetail.id detail_id, orderdetail.items_id, orderdetail.items_num items.name items_name, items.detail items_detail FROM orders, USER, orderdetail, items WHERE user.`id` = orders.`user_id` AND orders.`id` = orderdetail.`orders_id` AND orderdetail.`items_id` = items.`id` 映射思路将用户信息映射到user中。在user类中添加订单列表属性Listorderslist，将用户创建的订单映射到orderslist在Orders中添加订单明细列表属性ListdetailList，将订单的明细映射到detailList在Orderdetail中添加Items属性，将订单明细所对应的商品映射到Items修改PO类&emsp;&emsp;在user类中添加ListordersList 属性// 订单信息 private List&lt;Orders&gt; ordersList; &emsp;&emsp;在Orders类中添加List属性//订单明细 private List&lt;Orderdetail&gt; detailList; &emsp;&emsp;在Orderdetail类中添加Items属性//商品信息 private Items items; 编写mapper接口//查询用户及用户购买商品信息（多对多映射之使用resultMap） public List&lt;User&gt; findUserAndItemsRstMap(); 编写映射文件//&lt;!-- 定义UserAndItemsRstMap --&gt; &lt;resultMap type=&quot;User&quot; id=&quot;UserAndItemsRstMap&quot;&gt; &lt;!-- 用户信息 --&gt; &lt;!-- id：关联查询用户的唯一标示 --&gt; &lt;id column=&quot;user_id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot; /&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot; /&gt; &lt;!-- 订单信息 （一个用户有多个订单） --&gt; &lt;collection property=&quot;ordersList&quot; ofType=&quot;orders&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;number&quot; property=&quot;number&quot; /&gt; &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot; /&gt; &lt;result column=&quot;note&quot; property=&quot;note&quot; /&gt; &lt;!-- 订单明细信息（一个订单有多个订单明细） --&gt; &lt;collection property=&quot;detailList&quot; ofType=&quot;orderdetail&quot;&gt; &lt;id column=&quot;detail_id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot; /&gt; &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot; /&gt; &lt;!-- 商品信息 （一个订单明细对应一个商品） --&gt; &lt;association property=&quot;items&quot; javaType=&quot;cn.itcast.mybatis.po.Items&quot;&gt; &lt;id column=&quot;items_id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;items_name&quot; property=&quot;name&quot; /&gt; &lt;result column=&quot;items_detail&quot; property=&quot;detail&quot; /&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询用户及用户购买商品信息（多对多映射之使用resultMap） --&gt; &lt;select id=&quot;findUserAndItemsRstMap&quot; resultMap=&quot;UserAndItemsRstMap&quot;&gt; Select &lt;include refid=&quot;select_orders&quot; /&gt; , &lt;include refid=&quot;select_user&quot; /&gt; , &lt;include refid=&quot;select_orderdetail&quot;&gt;&lt;/include&gt; , items.name items_name, items.detail items_detail from orders,user,orderdetail,items where orders.user_id = user.id and orders.id = orderdetail.orders_id and orderdetail.items_id = items.id &lt;/select&gt; 编写测试代码//@Test public void testFindUserAndItemsRstMap() { // 创建sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession构造usermapper的代理对象 OrdersMapper ordersMapper = sqlSession.getMapper(OrdersMapper.class); // 调用usermapper的方法 List&lt;User&gt; list = ordersMapper.findUserAndItemsRstMap(); // 此处我们采用debug模式来跟踪代码，然后验证结果集是否正确 System.out.println(list); // 释放SqlSession sqlSession.close(); } 多对多查询小结&emsp;&emsp;将查询用户购买的商品信息明细清单，（用户名、用户地址、购买商品名称、购买商品时间、购买商品数量）&emsp;&emsp;针对上边的需求就使用resultType将查询到的记录映射到一个扩展的pojo中，很简单实现明细清单的功能。&emsp;&emsp;一对多是多对多的特例，如下需求：//查询用户购买的商品信息，用户和商品的关系是多对多关系。需求1：&emsp;&emsp;&emsp;&emsp;查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见)&emsp;&emsp;&emsp;&emsp;企业开发中常见明细列表，用户购买商品明细列表，使用resultType将上边查询列映射到pojo输出。需求2：&emsp;&emsp;&emsp;&emsp;查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细）&emsp;&emsp;&emsp;&emsp;使用resultMap将用户购买的商品明细列表映射到user对象中。总结：&emsp;&emsp;使用resultMap是针对那些对查询结果映射有特殊要求的功能，，比如特殊要求映射成list中包括 多个list。高级映射总结resultType：&emsp;&emsp;作用：&emsp;&emsp;&emsp;&emsp;将查询结果按照sql列名pojo属性名一致性映射到pojo中。&emsp;&emsp;场合：&emsp;&emsp;&emsp;&emsp;常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。resultMap：&emsp;&emsp;使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。association：&emsp;&emsp;作用：&emsp;&emsp;&emsp;&emsp; 将关联查询信息映射到一个pojo对象中。&emsp;&emsp;场合：&emsp;&emsp;&emsp;&emsp;为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。// &emsp;&emsp;使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。collection：&emsp;&emsp;作用：&emsp;&emsp;&emsp;&emsp; 将关联查询信息映射到一个list集合中。&emsp;&emsp;场合：&emsp;&emsp;&emsp;&emsp;为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。//&emsp;&emsp; 如果使用resultType无法将查询结果映射到list集合中。延迟加载什么是延迟加载&emsp;&emsp;resultMap中的association和collection标签具有延迟加载的功能。&emsp;&emsp;延迟加载的意思是说，在关联查询时，利用延迟加载，先加载主信息。需要关联信息时再去按需加载关联信息。这样会大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。设置延迟加载&emsp;&emsp;Mybatis默认是不开启延迟加载功能的，我们需要手动开启。&emsp;&emsp;需要在SqlMapConfig.xml文件中，在标签中开启延迟加载功能。设置项描述允许值默认值lazyLoadingEnabled全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。true or falsetrueaggressiveLazyLoading当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。true or falsetrue使用association进行延迟加载需求&emsp;&emsp;查询订单并且关联查询用户信息（对用户信息的加载要求是按需加载）编写映射文件&emsp;&emsp;需要定义两个mapper的方法对应的statement。只查询订单信息SELECT * FROM orders&emsp;&emsp;在查询订单的statement中使用association去延迟加载（执行）下边的satatement(关联查询用户信息) //&lt;!-- 定义OrdersUserLazyLoadingRstMap --&gt; &lt;resultMap type=&quot;cn.itcast.mybatis.po.Orders&quot; id=&quot;OrdersUserLazyLoadingRstMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; /&gt; &lt;result column=&quot;number&quot; property=&quot;number&quot; /&gt; &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot; /&gt; &lt;result column=&quot;note&quot; property=&quot;note&quot; /&gt; &lt;!-- 延迟加载用户信息 --&gt; &lt;!-- select：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement） 我们使用UserMapper.xml中的findUserById完成根据用户ID（user_id）查询用户信息 如果findUserById不在本mapper中，前边需要加namespace --&gt; &lt;!-- column：主信息表中需要关联查询的列，此处是user_id --&gt; &lt;association property=&quot;user&quot; select=&quot;cn.itcast.mybatis.mapper.UserMapper.findUserById&quot; column=&quot;user_id&quot;&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 查询订单信息，延迟加载关联查询的用户信息 --&gt; &lt;select id=&quot;findOrdersUserLazyLoading&quot; resultMap=&quot;OrdersUserLazyLoadingRstMap&quot;&gt; SELECT * FROM orders &lt;/select&gt; 关联查询用户信息&emsp;&emsp;通过上边查询到的订单信息中user_id去关联查询用户信息,使用UserMapper.xml中的findUserById123//&lt;select id="findUserById" parameterType="int" resultType="cn.itcast.mybatis.po.User"&gt; SELECT * FROM user WHERE id = #&#123;id&#125;&lt;/select&gt;&emsp;&emsp;&emsp;&emsp;上边先去执行findOrdersUserLazyLoading，当需要去查询用户的时候再去执行findUserById，通过resultMap的定义将延迟加载执行配置起来。加载映射文件//&lt;!-- 批量加载mapper文件，需要mapper接口文件和mapper映射文件名称相同且在同一个包下 --&gt; &lt;package name=_&quot;cn.itcast.mybatis.mapper&quot;_/&gt; 编写mapper接口// 查询订单信息，延迟加载关联查询的用户信息 public List&lt;Orders&gt; findOrdersUserLazyLoading(); 编写测试代码思路：执行上边mapper方法（findOrdersUserLazyLoading），内部去调用cn.itcast.mybatis.mapper.OrdersMapper中的findOrdersUserLazyLoading只查询orders信息（单表）。在程序中去遍历上一步骤查询出的List，当我们调用Orders中的getUser方法时，开始进行延迟加载。执行延迟加载，去调用UserMapper.xml中findUserbyId这个方法获取用户信息。1234567891011121314//@Testpublic void testFindOrdersUserLazyLoading() &#123; // 创建sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession构造usermapper的代理对象 OrdersMapper ordersMapper = sqlSession.getMapper(OrdersMapper.class); // 调用usermapper的方法 List&lt;Orders&gt; list = ordersMapper.findOrdersUserLazyLoading(); for(Orders orders : list)&#123; System.out.println(orders.getUser()); &#125; // 释放SqlSession sqlSession.close();&#125;延迟加载思考&emsp;&emsp;不使用mybatis提供的association及collection中的延迟加载功能，如何实现延迟加载？？&emsp;&emsp;实现方法如下：&emsp;&emsp;//定义两个mapper方法：查询订单列表根据用户id查询用户信息实现思路：先去查询第一个mapper方法，获取订单信息列表在程序中（service），按需去调用第二个mapper方法去查询用户信息。总之：&emsp;&emsp;使用延迟加载方法，先去查询简单的sql（最好单表，也可以关联查询），再去按需要加载关联查询的其它信息。查询缓存mybatis缓存分析&emsp;&emsp;mybatis提供查询缓存，如果缓存中有数据就不用从数据库中获取，用于减轻数据压力，提高系统性能。&emsp;&emsp;一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。&emsp;&emsp;二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。一级缓存原理&emsp;&emsp;第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。&emsp;&emsp;得到用户信息，将用户信息存储到一级缓存中。&emsp;&emsp;如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。&emsp;&emsp;第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。注：Mybatis默认支持一级缓存。测试1//@Test public void testOneLevelCache() { SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库 User user1 = mapper.findUserById(1); System.out.println(user1); // 第二次查询ID为1的用户 User user2 = mapper.findUserById(1); System.out.println(user2); sqlSession.close(); } &emsp;&emsp;只输出一次SQL：测试2//@Test public void testOneLevelCache() { SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库 User user1 = mapper.findUserById(1); System.out.println(user1); User user = new User(); user.setUsername(&quot;东哥1&quot;); user.setAddress(&quot;清河宝盛西里&quot;); //执行增删改操作，清空缓存 mapper.insertUser(user); // 第二次查询ID为1的用户 User user2 = mapper.findUserById(1); System.out.println(user2); sqlSession.close(); } &emsp;&emsp;中间执行了commit操作，同样的查询SQL输出两次：应用&emsp;&emsp;正式开发，是将mybatis和spring进行整合开发，事务控制在service中。&emsp;&emsp;一个service方法中包括 很多mapper方法调用。//service{ //开始执行时，开启事务，创建SqlSession对象 //第一次调用mapper的方法findUserById(1) //第二次调用mapper的方法findUserById(1)，从一级缓存中取数据 //方法结束，sqlSession关闭 } &emsp;&emsp;如果是执行两次service调用查询相同 的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空。二级缓存原理&emsp;&emsp;下图是多个sqlSession请求UserMapper的二级缓存图解。&emsp;&emsp;二级缓存是mapper级别的。&emsp;&emsp;第一次调用mapper下的SQL去查询用户信息。查询到的信息会存到该mapper对应的二级缓存区域内。&emsp;&emsp;第二次调用相同namespace下的mapper映射文件中相同的SQL去查询用户信息。会去对应的二级缓存内取结果。&emsp;&emsp;如果调用相同namespace下的mapper映射文件中的增删改SQL，并执行了commit操作。此时会清空该namespace下的二级缓存。开启二级缓存注：Mybatis默认是没有开启二级缓存在核心配置文件SqlMapConfig.xml中加入以下内容（开启二级缓存总开关）：在settings标签中添加以下内容：&lt;!-- 开启二级缓存总开关 --&gt; &lt;setting name=_&quot;cacheEnabled&quot;_ value=_&quot;true&quot;_/&gt; 在UserMapper映射文件中，加入以下内容，开启二级缓存：实现序列化&emsp;&emsp;由于二级缓存的数据不一定都是存储到内存中，它的存储介质多种多样，所以需要给缓存的对象执行序列化。&emsp;&emsp;如果该类存在父类，那么父类也要实现序列化。测试1//@Test public void testTwoLevelCache() { SqlSession sqlSession1 = sqlSessionFactory.openSession(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); SqlSession sqlSession3 = sqlSessionFactory.openSession(); UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class); UserMapper mapper3 = sqlSession3.getMapper(UserMapper.class); // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库 User user1 = mapper1.findUserById(1); System.out.println(user1); // 关闭SqlSession1 sqlSession1.close(); // 第二次查询ID为1的用户 User user2 = mapper2.findUserById(1); System.out.println(user2); // 关闭SqlSession2 sqlSession2.close(); } &emsp;SQL输出结果：&emsp;Cache Hit Radio ： 缓存命中率第一次缓存中没有记录，则命中率0.0；第二次缓存中有记录，则命中率0.5（访问两次，有一次命中）测试2//@Test public void testTwoLevelCache() { SqlSession sqlSession1 = sqlSessionFactory.openSession(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); SqlSession sqlSession3 = sqlSessionFactory.openSession(); UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class); UserMapper mapper3 = sqlSession3.getMapper(UserMapper.class); // 第一次查询ID为1的用户，去缓存找，找不到就去查找数据库 User user1 = mapper1.findUserById(1); System.out.println(user1); // 关闭SqlSession1 sqlSession1.close(); //修改查询出来的user1对象，作为插入语句的参数 user1.setUsername(&quot;东哥1&quot;); user1.setAddress(&quot;清河宝盛西里&quot;); mapper3.insertUser(user1); // 提交事务 sqlSession3.commit(); // 关闭SqlSession3 sqlSession3.close(); // 第二次查询ID为1的用户 User user2 = mapper2.findUserById(1); System.out.println(user2); // 关闭SqlSession2 sqlSession2.close(); } &emsp;SQL输出结果：&emsp;&emsp;根据SQL分析，确实是清空了二级缓存了。禁用二级缓存&emsp;&emsp;该statement中设置userCache=false，可以禁用当前select语句的二级缓存，即每次查询都是去数据库中查询，默认情况下是true，即该statement使用二级缓存。//&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot; useCache=&quot;true&quot;&gt; SELECT * FROM user WHERE id = #{id} &lt;/select&gt; 刷新二级缓存&emsp;&emsp;该statement中设置flushCache=true可以刷新当前的二级缓存，默认情况下如果是select语句，那么flushCache是false。如果是insert、update、delete语句，那么flushCache是true。如果查询语句设置成true，那么每次查询都是去数据库查询，即意味着该查询的二级缓存失效。如果查询语句设置成false，即使用二级缓存，那么如果在数据库中修改了数据，而缓存数据还是原来的，这个时候就会出现脏读。&emsp;flushCache设置如下：1234//&lt;select id="findUserById" parameterType="int" resultType="cn.itcast.mybatis.po.User" useCache="true" flushCache="true"&gt; SELECT * FROM user WHERE id = #&#123;id&#125;&lt;/select&gt;整合ehcache（了解）&emsp;&emsp;Ehcache是一个分布式缓存。分布式缓存&emsp;&emsp;系统为了提高性能，通常会对系统采用分布式部署（集群部署方式）&emsp;&emsp;不使用分布式缓存，缓存的数据在各个服务单独存储，不方便开发。所以要使用分布式缓存对缓存数据进行集中式管理。&emsp;&emsp;Mybatis自身无法实现分布式缓存，需要和其它分布式缓存框架进行整合。整合思路（重点）Mybatis提供了一个cache接口，同时它自己有一个默认的实现类PerpetualCache。通过实现cache接口可以实现mybatis缓存数据通过其他缓存数据库整合，mybatis的特长是sql，缓存数据管理不是mybatis的特长，为了提高mybatis的性能，所以需要mybatis和第三方缓存数据库整合，比如ehcache、memcache、redis等&emsp;Mybatis提供接口如下：&emsp;&emsp;Mybatis的默认实现类：整合ehcache的步骤引入ehcache的jar包；在mapper映射文件中，配置cache标签的type为ehcache对cache接口的实现类类型。加入ehcache的配置文件第一步：引入ehcache的jar包ehcache-core-2.6.5.jarmybatis-ehcache-1.0.2.jar第二步：配置cache的type属性&lt;!-- 使用默认二级缓存 --&gt; &lt;cache type=_&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;_ /&gt; 第三步：添加ehcache的配置文件&emsp;&emsp;在classpath下添加ehcache.xml//&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;!-- 缓存数据要存放的磁盘地址 --&gt; &lt;diskStore path=&quot;F:\develop\ehcache&quot; /&gt; &lt;!-- diskStore：指定数据在磁盘中的存储位置。  defaultCache：当借助CacheManager.add(&quot;demoCache&quot;)创建Cache时，EhCache便会采用&lt;defalutCache/&gt;指定的的管理策略 以下属性是必须的： maxElementsInMemory - 在内存中缓存的element的最大数目 maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大  eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断 overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上 以下属性是可选的： timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大 timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB-这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区. diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。 diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作 memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --&gt; &lt;defaultCache maxElementsInMemory=&quot;1000&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;/defaultCache&gt; &lt;/ehcache&gt; 应用场景&emsp;使用场景：对于访问响应速度要求高，但是实时性不高的查询，可以采用二级缓存技术。注意：在使用二级缓存的时候，要设置一下刷新间隔（cache标签中有一个flashInterval属性）来定时刷新二级缓存，这个刷新间隔根据具体需求来设置，比如设置30分钟、60分钟等，单位为毫秒。局限性Mybatis二级缓存对细粒度的数据级别的缓存实现不好。&emsp;场景：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次查询都是最新的商品信息，此时如果使用二级缓存，就无法实现当一个商品发生变化只刷新该商品的缓存信息而不刷新其他商品缓存信息，因为二级缓存是mapper级别的，当一个商品的信息发送更新，所有的商品信息缓存数据都会清空。&emsp;&emsp;解决此类问题，需要在业务层根据需要对数据有针对性的缓存。比如可以对经常变化的数据操作单独放到另一个namespace的mapper中。mybatis与spring集成集成思路需要spring来管理数据源信息。需要spring通过单例方式管理SqlSessionFactory。使用SqlSessionFactory创建SqlSession。（spring和mybatis整合自动完成）持久层的mapper都需要由spring进行管理，spring和mybatis整合生成mapper代理对象。集成步骤jar包集成；配置文件集成（数据源）；SqlSessionFactory集成；Mapper接口集成；开始集成搭建工程结构包集成&emsp;&emsp;Jar包如下：Mybatis3.2.7 的jar包（mybatis核心包、依赖包）Spring3.2.0 的jar包Spring与mybatis的集成包:mybatis-spring-1.2.2.jar数据库驱动包:mysql-connector-java-5.1.7-bin.jarJunit包:junit-4.9.jarDbcp连接池包配置文件集成注意：Mybatis的配置文件中的数据源配置去掉，由spring进行管理配置。Mybatis的SqlMapConfig.xml//&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 设置全局参数 --&gt; &lt;settings&gt; &lt;!-- lazyLoadingEnabled：延迟加载的开关，默认是false --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- aggressiveLazyLoading：默认为true，一旦为true上面的懒加载开关失效 --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;!-- cacheEnabled：二级缓存的总开关 默认是false--&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;!-- 定义别名 --&gt; &lt;typeAliases&gt; &lt;!-- 批量定义别名 --&gt; &lt;!-- name：指定需要别名定义的包的名称 它的别名就是类名（类名的首字母大小写都可）--&gt; &lt;package name=&quot;cn.itcast.ssm.po&quot;&gt;&lt;/package&gt; &lt;/typeAliases&gt; &lt;!-- 注意：与spring集成后，数据源和事务交给spring来管理 --&gt; &lt;!-- 加载mapper文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/sqlmap/User.xml&quot;&gt;&lt;/mapper&gt; &lt;!-- 批量加载mapper 注意：mapper接口文件和mapper映射文件，名称相同，在同一个包下 --&gt; &lt;package name=&quot;cn.itcast.mybatis.mapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; Spring的applicationContext.xml//&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt; &lt;!-- 引用java配置文件 --&gt; &lt;context:property-placeholder location=&quot;db.properties&quot;/&gt; &lt;!-- 配置数据源，使用dbcp连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${db.driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${db.url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${db.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${db.password}&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; Spring对SqlSessionFactory进行管理配置&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- mybatis的配置文件路径 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;sqlMapConfig.xml&quot;&gt;&lt;/property&gt; &lt;!-- SqlSessionFactory需要数据源信息，之前是写在sqlmapconfig.xml，现在需要重新指定 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; Mybatis程序编写原始dao方式编写dao接口//public interface UserDao { // 1、 根据用户ID来查询用户信息； public User findUserById(int id); // 2、 根据用户名称来模糊查询用户信息列表； public List&lt;User&gt; findUsersByName(String name); // 3、 添加用户； public void insertUser(User user); } 编写dao实现类（继承SqlSessionDaoSupport）//通过this.getSqlSession()获取sqlsession。 public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao { @Override public User findUserById(int id) { return this.getSqlSession().selectOne(&quot;test.findUserById&quot;, id); } } 编写Mapper映射文件Spring定义bean//&lt;!-- 由spring管理原始dao的实现 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.mybatis.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; 编写测试代码//public class UserDaoTest { //spring上下文 private ApplicationContext ctx; @Before public void setUp() throws Exception { //读取spring的上下文，然后封装到ctx ctx = new ClassPathXmlApplicationContext(&quot;spring/applicationContext.xml&quot;); } @Test public void testFindUserById() { //创建userdao对象 UserDao userDao = (UserDao) ctx.getBean(&quot;userDao&quot;); //调用userdao对象的方法 User user = userDao.findUserById(1); System.out.println(user); } } Mapper代理方式编写mapper接口public interface UserMapper { // 1、 根据用户ID来查询用户信息 public User findUserById(int id); } 编写mapper映射文件Spring定义bean&emsp;&emsp;Mapper代理开发方式有两种bean的定义方法，一种是MapperFactoryBean，一种是MapperScannerConfigurer（推荐）。通过MapperFactoryBean创建代理对象（了解）&lt;!-- mapper代理开发方式之单个mapper配置 --&gt; &lt;bean id=&quot;userMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt; &lt;property name=&quot;mapperInterface&quot; value=&quot;cn.itcast.mybatis.mapper.UserMapper&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 通过MapperScannerConfigurer批量扫描创建代理对象（掌握）&emsp;&emsp;存在问题：一个mapper定义一个bean，很麻烦。//&lt;!-- mapper代理开发方式之批量mapper配置 --&gt; &lt;!-- bean的名字默认为mapper接口类名的首字母小写 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 指定批量mapper配置的包名 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.itcast.mybatis.mapper&quot;&gt;&lt;/property&gt; &lt;!-- 指定使用的SqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 编写测试代码//private ApplicationContext ctx; @Before public void setUp() throws Exception { ctx = new ClassPathXmlApplicationContext( &quot;spring/applicationContext.xml&quot;); } @Test public void testFindUserById() { // 创建mapper对象 UserMapper userMapper = (UserMapper) ctx.getBean(&quot;userMapper&quot;); // 调用mapper对象的方法 User user = userMapper.findUserById(1); System.out.println(user); } Mybatis的逆向工程（会用）什么是逆向工程&emsp;&emsp;简单点说，就是通过数据库中的单表，自动生成java代码。&emsp;&emsp;Mybatis官方提供了逆向工程，可以针对单表自动生成mybatis代码（mapper.java\mapper.xml\po类）&emsp;&emsp;企业开发中，逆向工程是个很常用的工具。下载逆向工程https://github.com/mybatis/generator/releases/tag/mybatis-generator-1.3.2使用方法创建generator配置文件；使用java类来执行逆向工程；把生成的代码拷贝到项目中。在正式项目中使用逆向工程生成的代码第一步：创建generator配置文件&emsp;&emsp;在classpath下，创建generator.xml配置文件：（文件内容可以从逆向工程的jar包中docs目录下的index.html中找到相关代码）//&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot; password=&quot;mysql&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot; connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot; userId=&quot;yycg&quot; password=&quot;yycg&quot;&gt; &lt;/jdbcConnection&gt; --&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;cn.itcast.ssm.po&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;cn.itcast.ssm.mapper&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;cn.itcast.ssm.mapper&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName=&quot;items&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;orders&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;orderdetail&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 第二步：使用java类来执行逆向工程//public class Generator { /** *@param args */ public static void main(String[] args) throws Exception{ List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;config/generator.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); } } 第三步：把生成的代码拷贝到项目中如果正式项目中已经有po类所在的包了，那么就只需要拷贝po类到指定包下就可以。如果正式项目中没有po包，那么就把逆向工程中整个po类的包拷贝过去。Mapper.xml和mapper.java的拷贝与po类一样。第四步：使用生成的代码//public class ItemsMapperTest { // spring上下文 private ApplicationContext ctx; @Before public void setUp() throws Exception { // 读取spring的上下文，然后封装到ctx ctx = new ClassPathXmlApplicationContext( &quot;spring/applicationContext.xml&quot;); } @Test public void testSelectByExample() { ItemsMapper mapper = (ItemsMapper) ctx.getBean(&quot;itemsMapper&quot;); ItemsExample example = new ItemsExample(); //使用它进行参数封装传递 Criteria criteria = example.createCriteria(); //设置参数 criteria.andNameEqualTo(&quot;背包&quot;); List&lt;Items&gt; list = mapper.selectByExample(example); System.out.println(list); } } 注意事项&emsp;&emsp;Mapper.xml文件已经存在时，如果进行重新生成则mapper.xml文件时，内容不被覆盖而是进行内容追加，结果导致mybatis解析失败。解决方法：删除原来已经生成的mapper.xml文件再进行生成。Mybatis自动生成的po及mapper.java文件不是内容而是直接覆盖没有此问题。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2学习笔记]]></title>
    <url>%2F2018%2F07%2F23%2FStruts2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[知识导入xml解析&emsp;&emsp; dom4j解析反射&emsp;&emsp; 有完整类名，并且含有空参构造函数，如何创建出对象？//使用反射创建对象 Class clazz = Class.forName(&quot;xxx&quot;); clazz.newInstance(); filter过滤器过滤来自浏览器发送的请求.在请求到达访问资源之前.会先经过过滤器.可以完成批处理. 还可以根据filterChain来决定是否放行.也可以使用请求转发,或重定向,不让请求到目标路径.自己定义一个struts-MiniStruts2基础框架相关什么是框架？&emsp; 微观：由一个一个类构成的包，包再构成框架&emsp; 宏观：半成品的项目，我们需要执行什么业务时，为框架填写业务逻辑即可三大框架：SSH=&gt;Struts,Spring,Hibernate&emsp; Struts的版本：&emsp;&emsp; Struts1（已经淘汰）&emsp;&emsp; Struts2（我们要学的）也叫xwork。三大框架的作用？&emsp; 简化我们的开发，降低开发成本，提高开发效率&emsp;Struts=&gt; WEB层框架：&emsp;&emsp; 优势：&emsp;&emsp; &emsp; 1.不用侵入性比较高的Servlet.可以直接写普通java类作为处理请求逻辑的处理类.这样更易于测试.&emsp;&emsp; &emsp; 2.整合了一些之前需要手动来做的功能. 后台验证,表单回显,自动将表单参数封装,防止表单重复提交，如果不够用我们还可以扩展框架的功能.Struts2的HelloWorld1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 //--------------------------------- //cn.pinzhi.action.HelloAction //----------------------------- package cn.pinzhi.action; public class HelloAction &#123; public String execute()&#123; System.out.println("hello world"); return "success"; // 结果页面命名 &#125; &#125;//----------------------------------------- //src下的struts.xml //------------------------------------------ &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE struts PUBLIC"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN""http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt;&lt;!-- name:单纯的给包起一个名字，不要与其他包名重复 namespace:为action访问加上一层或多层路径 etends：继承一个其他包，目的是引入其他包的配置 --&gt; &lt;package name="hello" namespace="/" extends="struts-default"&gt; &lt;!--name:为action类加上一个标识，在访问时填入name名称，就可以找到action class：action完整类名 method：处理的方法 --&gt; &lt;action name="hello" class="cn.pinzhi.action.HelloAction" method="execute"&gt; &lt;!--name：返回结果的标识，用于找到结果路径 type：可以决定跳转到结果的方式=》转发，重定向。。。 --&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; //------------------------------------ //web.xml //------------------------------------ &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;display-name&gt;helloStruts&lt;/display-name&gt; &lt;!-- 重要：配置struts2的核心过滤器 --&gt; &lt;!--配置struts2的过滤器，要放到其他过滤器后面，保证其他过滤器可以执行 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; //---------------------------struts2的架构struts2的架构图解struts2中的6个配置文件default.properties ：用于配置struts 常量。例如：编码struts-default.xml ：struts提供的默认核心配置文件，struts大部分功能都在此配置文件中。struts-plugin.xml ： struts插件核心配置文件，struts整合其他框架或工具。以上三个文件，用户自己不进行修改。struts.xml ：用户自定义核心配置文件。&emsp; struts.xml 可以配置所有内容，包括：常量,如：&emsp;&emsp; &lt; constant name=”struts.i18n.encoding” value=”GBK”&gt; &lt; /constant&gt; //配置编码struts.properties ： 用于自定义struts常量配置文件。一般不使用。web.xml ：也可以配置struts常量@@@注意：如果配置常量，所有的配置文件存在优先级，编号越大优先级越高。常见的struts常量用于配置项目编码//struts.i18n.encoding=UTF-8struts整合spring需要配置，默认注释掉了//struts.objectFactory = springstruts默认使用文件上传解析工具：apache-commons-fileuploadstruts.multipart.parser=jakarta临时文件保存位置//struts.multipart.saveDir=上传文件最大大小，默认值：2M，单位字节//struts.multipart.maxSize用于设置action请求路径扩展名。默认：action或空。多个值使用逗号分隔//struts.action.extension=action,,例如：/hello/userAction 或 /hello/userAction.action确定是否使用动态方法调用。默认关闭的。//struts.enable.DynamicMethodInvocation = false设置开发模式，默认关闭。如果设置true：将提供更多提示信息，自动加载文件。//struts.devMode = false自动重新加载国际化资源文件//struts.i18n.reload = true自动冲洗加载xml配置文件。例如：struts.xml。但不会自动加载action类。//struts.configuration.xml.reload = true设置struts标签主题，默认值：xhtml。取值：simple。//struts.ui.theme=xhtml//开发中常用simple。xhtml存在默认布局，开发中布局使用美工提供页面，布局自定义。struts.xml详解&lt; constant&gt; 用于配置struts常量—-name：struts提供固定常量名称。此名称从 default.properties文件获得—-value：常量值例如：&lt;constant name=”struts.devMode” value=”true”&gt; &lt;/constant&gt;&lt;package&gt; struts用于管理所有action类—-name：给当前包进行唯一命名，必填项。用于其他包继承的。例如：struts-default.xml//&lt;package name=”struts-default” abstract=”true”&gt; //将struts已经完成的功能，作为一个包存在。名称是固定值struts-default。—-namespace：action访问路径前缀。例如：”/““/hello”“/a/b/c”“”—-extends：用于继承其他包的。例如：&lt;package extends=”struts-default”&gt; 当前action继承struts已经完成功能。—-abstract：是否抽象，如果设置为true，表示没有具体action实现功能。(了解)&lt;action&gt; 用于配置action类（请求处理类）—-name：action名称，用于在请求路径进行访问—-class：action类全限定类名—-method:用于确定action类中需要执行的方法，默认值：execute&lt;result&gt; 用于配置结果集—-name：用于确定action类中，方法的返回值—-text：标签体用于设置jsp路径—-type:结果集类型&emsp; —- dispatcher：请求转发，从一个action到jsp页面，默认值。&emsp;—- redirect：重定向到jsp页面&emsp;—- redirectAction：重定向到另一个action&emsp;—- stream：以流的方法发送浏览器，用于文件下载。&emsp;—- chain：链，在一次请求中，从一个action到另一个action&lt;result-types&gt; 用于配置结果集类型的，一般不用，但需要看的懂。&lt;interceptors&gt; 用于配置拦截器—- &lt;interceptor&gt; 用于注册拦截器的—-&lt;interceptor-stack&gt; 拦截器栈，将已经注册的拦截器组合在一起，形成一个栈。例如：&lt;interceptor-stack name=”defaultStack”&gt; 声明一个拦截器栈，名称是：defaultStack&lt;default-interceptor-ref&gt; 用于确定当前默认拦截器的例如：&lt;default-interceptor-ref name=”defaultStack”/&gt; 将“defaultStack”拦截器栈，声明默认拦截器栈&lt;default-action-ref&gt; 如果访问的action不存在，默认执行的aciton。例如：/a/b/c/d/oneAction 此aciton没有配置，默认情况返回action找不到!!!如果配置&lt;default-action-ref&gt; 如果存在404时，不显示action找不到，而是指定action&lt;default-class-ref &gt; 用于配置 默认action实现类例如：&lt;default-class-ref class=”com.opensymphony.xwork2.ActionSupport” /&gt;!!!如果编写配置文件时没有声明class属性，及&lt;action name=””&gt; 将执行ActionSupport类。&lt;include&gt; 将多个struts配置文件组合成一个。struts.xml 入口配置文件，大家共用的。用于存放通用模块。&emsp;&lt;include file=”struts-user.xml” /&gt;&emsp;&lt;include file=”struts-book.xml” /&gt;提供子配置文件&emsp;struts-user.xml&emsp;struts-book.xmlaction访问动态方法调用格式： action名称!方法名称.action例如：bookAction!add.action1234567891011121314151617181920212223&lt;!-------- jsp文件配置action入口 ----------&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/bookAction!add.action"&gt;动态方法调用--add&lt;/a&gt; &lt;br/&gt;&lt;!-------- struts.xml 配置 ----------&gt;&lt;!-- 注意：默认情况动态方法调用关闭的，必须通过struts常量进行配置。 --&gt;&lt;!-- 设置动态方法调用 --&gt;&lt;constant name="struts.enable.DynamicMethodInvocation" value="true"&gt;&lt;/constant&gt;&lt;!-- 案例2：动态方法调用 --&gt; &lt;action name="bookAction" class="cn.itcast.b_demo.BookAction"&gt; &lt;result name="success"&gt;/b_demo/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;!-- action类，提供两个方法 位置：/struts_day01/src/cn/itcast/b_demo/BookAction.java--&gt;public class BookAction &#123; public String execute()&#123; System.out.println("bookAction execute()"); return "success"; &#125; public String add()&#123; System.out.println("bookAction add()"); return "success"; &#125;&#125;通配符&lt;action name=&quot;userAction&quot;&gt; , action.name可以使用通配符星号(*)，在action.class、aciton.method、result.name 处可以使用{n}方式匹配星号。例如：userAction_* 将可以通过{1}方法获得第一个星号匹配到内容。请求路径/userAction_add ,&lt;action name=&quot;userAction_*&quot; method=&quot;{1}&quot;&gt;{1} 匹配的内容是add，将执行add方法userAction_*_*{1} 匹配第一个星；{2}匹配第二星请求路径 /userAction_add_success ,&lt;action name=&quot;userAction_*_*&quot; method=&quot;{1}&quot;&gt;&lt;resutl name=&quot;{2}&quot;&gt;{1}匹配add方法，{2}匹配返回值的名称success*_*_* 将采用多个分别描述不同的内容，一次{1}{2}{3}获得请求路径 /UserAction_add_success&lt;action name=&quot;*_*_*&quot; class=&quot;cn.itcast.action.{1}&quot; method=&quot;{2}&quot;&gt; &lt;result name=&quot;{3}&quot;&gt;/pages/{3}.jsp12345&lt;!-- 案例3：通配符 --&gt;&lt;action name="personAction_*" class="cn.itcast.c_demo.PersonAction" method="&#123;1&#125;"&gt; &lt;result name="add"&gt;/c_demo/add.jsp&lt;/result&gt; &lt;result name="update"&gt;/c_demo/update.jsp&lt;/result&gt;&lt;/action&gt;action访问路径&emsp;&emsp;当默认访问一个action时，package.namespace = /a/b/c优先从”/a/b/c”namespace获得相应的aciton，如果没有获得，将从”/a/b”中获得如果没有获得，将从”/a”中获得如果没有获得，将从”/“中获得如果没有获得，将从””中获得Action类与servlet APIAction类实现方法POJO类实现Action接口&emsp;&emsp;规范接口，将success (表示成功了),none(没有返回值。相当方法void。没有返回值表示没有result，常用与ajax操作。使用response发送数据),error(服务器异常),input(表示用户输入错误),login(表示需要权限)等字符串封装成相应的常量继承ActionSupport类&emsp;&emsp;ActionSupport类已经默认实现了Action(规范接口),Validateable(数据校验),ValidationAware(错误信息),TextPrivider(国际化)等接口方法定义123public String execute() throws Exception&#123; return SUCCESS;&#125;必须是public建议有返回值，类型必须String方法名称自定义没有参数需要throw Exception非静态的注意：可以没有返回值，一般情况都有，可以使用return “none” 表示没有返回。Struts.xml中struts-default包中的默认配置如果不手动配置Action 默认Action如下配置:&lt;default-class-ref class=&quot;com.opensymphony.xwork2.ActionSupport&quot; /&gt;如果不配置结果的type属性,默认type属性如下配置:&lt;result-type name=&quot;dispatcher&quot; class=&quot;org.apache.struts2.dispatcher.ServletDispatcherResult&quot; default=&quot;true&quot;/&gt;访问Servlet api完全解耦，但只能操作作用域不使用曾经学习过的servlet知识，可以去操作三个作用域ActionContext 工具类，action上下文对象获得实例：ActionContext.getContext()-api:&emsp;&emsp;ac.put(key,value) , 相当于操作request作用域。request.setAttribute(“key”,value)&emsp;&emsp;ac.getSession().put(key,value) ，相当于操作session作用域。session.setAttribute(“key”,value)&emsp;&emsp;ac.getApplication().put(key,value) ，相当于操作application作用域。servletContext.setAtt…12345678910 @Overridepublic String execute() throws Exception &#123; //1 request作用域 ActionContext.getContext().put("ds", "屌丝_request"); //2 session作用域 ActionContext.getContext().getSession().put("ds", "屌丝_session"); //3 application作用域 ActionContext.getContext().getApplication().put("ds", "屌丝——application"); return SUCCESS;&#125;操作servlet对象&emsp;ServletActionContext 工具类，获得需要servlet对象123456789-api： // 获得request对象 HttpServletRequest request = ServletActionContext.getRequest(); //2 获得response对象 HttpServletResponse response = ServletActionContext.getResponse(); //3获得servletContext对象 ServletContext servletContext = ServletActionContext.getServletContext(); //4 获得session HttpSession session = request.getSession();通过实现接口，struts注入需要实现指定的接口，此接口都提供setter，struts在执行action方法之前，将调用setter方法进行赋值。&emsp;ServletRequestAware //获得HttpServletRequest对象&emsp;ServletResponseAware //获得HttpServletResponse对象&emsp;ServletContextAware// 获得ServletContext对象123456789101112131415161718public class Demo5Action3 extends ActionSupport implements ServletRequestAware , ServletResponseAware ,ServletContextAware&#123; private HttpServletRequest request; private HttpServletResponse response; private ServletContext servletContext; private HttpSession session; @Override public void setServletRequest(HttpServletRequest request) &#123; this.session = request.getSession(); this.request = request; &#125; @Override public void setServletResponse(HttpServletResponse response) &#123; this.response = response; &#125; @Override public void setServletContext(ServletContext context) &#123; this.servletContext = context; &#125;结果集与参数控制结果集类型 Result123456789101112 &lt;!-- 案例 6.1 ：结果集类型,重定向jsp --&gt;&lt;action name="demo6Action" class="cn.itcast.f_demo.Demo6Action"&gt; &lt;result type="redirect"&gt;/f_demo/type.jsp&lt;/result&gt;&lt;/action&gt;&lt;!-- 案例 6.2 ：结果集类型,重定向action --&gt;&lt;action name="demo6Action2" class="cn.itcast.f_demo.Demo6Action2"&gt; &lt;result type="redirectAction"&gt;demo6Action3&lt;/result&gt;&lt;/action&gt;&lt;action name="demo6Action3" class="cn.itcast.f_demo.Demo6Action3"&gt; &lt;!-- 请求转发 ,默认值--&gt; &lt;result type="dispatcher"&gt;/f_demo/type.jsp&lt;/result&gt;&lt;/action&gt;封装请求参数属性封装只要在Action中提供与参数对应的set方法即可自动封装自动类型封装struts会自动转换8大基本数据类型和对应包装类.以及Date类型，其中date类型对数据提交格式有要求: yyyy-MM-dd容器数据封装容器：数组、List、Set、Map等12345678910111213141516171819&lt;!-- Jsp表单 --&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/demo2Action" method="post"&gt; Map&lt;br/&gt; &lt;input type="text" name="userMap['u001'].userName"/&gt; &lt;br/&gt; &lt;input type="text" name="userMap['u001'].userPwd"/&gt; &lt;br/&gt; &lt;input type="text" name="userMap['u002'].userName"/&gt; &lt;br/&gt; &lt;input type="text" name="userMap['u002'].userPwd"/&gt; &lt;br/&gt; List&lt;br/&gt; &lt;input type="text" name="userList[0].userName"/&gt; &lt;br/&gt; &lt;input type="text" name="userList[0].userPwd"/&gt; &lt;br/&gt; &lt;input type="text" name="userList[1].userName"/&gt; &lt;br/&gt; &lt;input type="text" name="userList[1].userPwd"/&gt; &lt;br/&gt; Array&lt;br/&gt; &lt;%-- request.getParameterValues("username") --%&gt; &lt;input type="checkbox" name="hobby" value="抽烟"/&gt; &lt;input type="checkbox" name="hobby" value="喝酒"/&gt; &lt;input type="checkbox" name="hobby" value="烫头"/&gt; &lt;br/&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt;123456789101112131415161718192021222324252627282930313233//Action类public class Demo2Action extends ActionSupport &#123; //封装到Map ,必须提供getter，所有封装需要使用同一个Map对象 private Map&lt;String,User&gt; userMap; public void setUserMap(Map&lt;String, User&gt; userMap) &#123; this.userMap = userMap; &#125; public Map&lt;String, User&gt; getUserMap() &#123; return userMap; &#125; //封装到List，必须提供getter，，所有封装需要使用同一个List对象 // * List&lt;User&gt; 和 User[] 等效的 private List&lt;User&gt; userList; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; public List&lt;User&gt; getUserList() &#123; return userList; &#125; //数组，不需要提供getter，直接一次性封装数据，使用String[] request.getParameterValues("hobby") private String[] hobby; public void setHobby(String[] hobby) &#123; this.hobby = hobby; &#125; @Override public String execute() throws Exception &#123; System.out.println(userMap); System.out.println(userList); System.out.println(hobby); System.out.println(Arrays.toString(hobby)); return "none"; &#125;&#125;类型转换默认支持类型转换字符串 与 指定类型 之间转换字符串 转成 指定类型：表单提交，浏览器发送服务器指定类型 转成 字符串：标签回显，服务器发送浏览器指定类型8个基本类型、以及包装类时间 Date，字符串有格式要求：yyyy-MM-dd 或 yyyy-MM-dd HH:mm:ss数组、List、Map自定义类型转换器实现类方案1：实现接口：TypeConverter，有一个方法，但参数过多。方案2：继承默认实现类：DefaultTypeConverter 。提供简洁方法convertValue(Object , Class)123456789101112131415161718192021convertValue(Object value , Class toType)#1 表单提交，浏览器发送到服务器。浏览器发送的肯定字符串String，需要转换成指定的类型。例如Date类型 -参数1：value，表示浏览器发送的数据。类型是String[] ,底层使用request.getParameterValues("...") -参数2：toType，表示需要转换的类型，java.uilt.Date类型具体操作 // 如果toType是 Date类型，表示希望将 字符串转成 时间 if(toType == java.util.Date.class)&#123; //获得数据 String[] params = (String[])value; //转成成时间 &#125;#2 标签回显，服务器发送 浏览器，类型之前已经从字符串转成时间，现在希望将时间再转换成 字符串。 -参数1：value，表示服务器已经转成好的时间。类型Date。 -参数2：toType，表示需要转换的类型，String类型具体操作 if(toType == String.class)&#123; // 将数据强转时间 Date date = (Date)value; // 格式化 &#125;注册转换器局部转换器：只对当前Action类有效。—限制：只能对action类的属性进行转化，不能对javabean中属性转换全局转换器：对所有的Action类有效。注意：自定义转换器很少使用，一般情况使用默认就可以。多读局部转换器的创建—位置：Action类同包—名称：action类的类名-conversion.properties—内容：属性=转换器//如birthday=cn.itcast.XXXCoverter全局转换器的创建—位置：src—名称：xwork-conversion.properties—内容：需要转换的类=转换器//如java.util.Data=cn.itcast.XXXConveter12345678910111213141516171819202122232425262728//-----转换器实现-----public Object convertValue(Object value, Class toType) &#123; try &#123; SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd"); //1 浏览器发送服务器--表单提交 // * value : String[] // * toType : Date if (toType == java.util.Date.class) &#123; // 1.1 强转，获得数据 String[] paramValues = (String[]) value; // 1.2 转成时间，返回 , 默认使用第一个 return dateFormat.parse(paramValues[0]); &#125; //2 服务器发送浏览器--标签回显 // * value : 服务器已经转换好的数据 Date // * toType : 需要类型 String if(toType == String.class)&#123; // 获得时间数据 java.util.Date date = (java.util.Date)value; // 格式化 return dateFormat.format(date); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; //执行其他 return null; &#125;自定义错误信息&emsp;&emsp;我们发现Struts2打印的类型转换错误信息是英文的，这说明我们需要自定义错误信息。自定义错误信息需要在Action所在目录下创建ActionName.properties文件（与Action同名的properties文件），然后在该文件中给出：invalid.fieldvalue.属性名=错误信息，其中invalid.fieldvalue是固定的。（注：若已使用前端校验，可不必配置此项）&emsp;&emsp;例如：invalid.fieldvalue.person=无法将请求参数转换成Person类型！校验器与拦截器校验数据校验校验分类-浏览器端校验：javaScript，但不安全-服务器端校验：struts校验struts校验手动校验：编写代码，适用于需要与数据库交互xml校验：编写配置文件，通用校验，逻辑简单。如：不能为空，长度为10等手动校验&emsp;&emsp;若需要手动校验，必须实现接口：validateable,它提供了一个方法validate()校验action中的所有方法—实现接口，并实现validate()方法校验action中的单个方法-实现接口并编写方法 validate方法() , 此处“方法”表示执行的方法名称，首字母大写。——例如：add() 执行前需要校验，必须编写 validateAdd()注意：先执行“单个方法”校验，再执行“所有方法”校验提供错误提示，阻止目标方法的执行—this.addFieldError(&quot;&quot;, &quot;&quot;)给指定的字段设置提示信息,&lt;s:fielderror&gt;jsp显示错误— this.addActionMessage(aMessage) action提示提示信息,&lt;s:actionmessage/&gt;jsp显示错误—this.addActionError(anErrorMessage)action错误, &lt;s:actionerror/&gt;jsp显示错误xml校验单个方法校验—位置：action类同包—名称：actionClass-actionName-validation.xml &amp;emsp;&amp;emsp;actionClass ：表示action类名 &amp;emsp;&amp;emsp;actionName：表示action访问名称，及&lt;action name=&quot;...&quot;&gt; &amp;emsp;&amp;emsp;validation.xml ：固定后缀 —内容：xml必须提供约束（DTD、schema[命名空间]） &amp;emsp;&amp;emsp;dtd文件位置：xwork-core-2.3.15.3.jar!/xwork-validator-1.0.3.dtd &amp;emsp;&amp;emsp;dtd文件内容： 123&lt;!DOCTYPE validators PUBLIC "-//Apache Struts//XWork Validator 1.0.3//EN" "http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd"&gt;所有方法校验—位置：action类同包—名称：actionClass-validation.xml—内容：同上struts提供的校验器—校验配置文件:xwork-core-2.3.15.3.jar!/com/opensymphony/xwork2/validator/validators/default.xml输入校验什么是输入校验？&emsp;&emsp;在Action封装了请求参数后，还需要对其进行校验。例如name不能为空，age只能在18~60之间等等！我们一定要搞清楚，输入校验是在类型转换成功之后，才可能执行的。校验分类：&emsp;&emsp;—JavaScript客户端校验（改善用户体验）；&emsp;&emsp;— 服务器端校验（保证安全性），即使用Struts2输入校验。Struts2输入校验的分类&emsp;&emsp;编程式校验；&emsp;&emsp; 配置校验：&emsp;&emsp;&emsp;&emsp;XML配置校验（了解）；编程式的输入校验&emsp;&emsp;覆盖ActionSupport类的validate()方法，在这个方法中完成对参数的校验。validate()方法会在参数封装之后，在execute()方法之前执行。如果validate()方法中向fieldError中添加了错误信息，那么就不会再执行execute()方法，而是跳转到input结果码对应的页面。1234567891011121314151617181920212223242526//---jsp文件中---&lt;s:fielderror /&gt;&lt;form action="&lt;c:url value='/Demo1Action.action'/&gt;" &gt; 用户名：&lt;input type="text" name="username"/&gt;&lt;br/&gt; 密 码：&lt;input type="password" name="password"/&gt;&lt;br/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;//---action.java中---public class Demo1Action extends ActionSupport &#123; private String username; private String password; @Override public void validate() &#123; if(username == null || username.trim().length() == 0) &#123; this.addFieldError("username", "用户名不能为空"); &#125; if(password == null || password.trim().length() == 0) &#123; this.addFieldError("password", "密码不能为空"); &#125; &#125; public String execute() &#123; System.out.println(username + ", " + password); return NONE; &#125;&#125;在validate方法中使用addFieldError(fieldName, errorMessage)方法存入字段的错误信息.使用addActionError(anErrorMessage)方法存入action的错误信息使用addActionMessage(aMessage)方法存入action提示信息在页面使用取出字段的错误信息使用取出action的错误信息使用取出action提示信息当然如果你的页面使用了struts2提供的表单标签.表单标签会自动显示字段的错误信息xml配置方式校验（了解）&emsp;&emsp;使用XML配置方式是先把常用的校验规则写好，然后在XML配置中指定要使用的校验规则。当然Struts2已经帮我们写好了很多的校验规则。我们只需要指在XML文档中配置当前的请求处理方法需要哪些校验规则。校验要求&emsp;&emsp;要使用XML配置方式校验，你的Action类必须实现Validateable接口。ActionSupport类已经实现了Validateable接口，所以我们通常是直接继承ActionSupport类。&emsp;&emsp;为属性提供getXXX()和setXXX()方法！代码校验是在Action本类中来完成校验，这说明我们可以直接使用本类的private属性，但如果使用XML配置方式校验，这需要使用校验框架的代码来完成校验工作，那么校验框架需要调用Action的getXXX()方法来获取被校验的属性，所以一定要为被校验的属性提供getXXX()方法。校验文件的创建校验文件的命名必须为：ActionName-validation.xml。例如LoginAction的校验文件命名为：LoginAction-validation.xml。校验文件的路径：必须与Action在同包下。校验文件的DTD：在xwork-core-x.x.x.jar中找到xwork-validator-x.x.x.dtd，打开它，内部会有一段DTD，我们把它copy过来，放到我们的校验文件中。校验文件的元素结果如下：123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- XWork Validators DTD. Used the following DOCTYPE. &lt;!DOCTYPE validators PUBLIC "-//Apache Struts//XWork Validator 1.0.3//EN" "http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd"&gt;--&gt;&lt;validators&gt; &lt;field name=""&gt; &lt;!-- name属性指定要校验的属性，例如&lt;feld name=”username”&gt;，表示要校验的属性是username属性。 --&gt; &lt;field-validator type=""&gt; &lt;!-- type属性指定校验规则，校验规则由Struts2提供， Struts2提供的所有校验规则在xwork-core包下的validator包中的default.xml内 --&gt; &lt;param name=""&gt;&lt;/param&gt; &lt;message&gt;&lt;/message&gt; &lt;/field-validator&gt; &lt;/field&gt;&lt;/validators&gt;&emsp;&emsp;struts2提供的校验规则(即上文提到的default.xml)：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE validators PUBLIC "-//Apache Struts//XWork Validator Definition 1.0//EN" "http://struts.apache.org/dtds/xwork-validator-definition-1.0.dtd"&gt;&lt;!-- START SNIPPET: validators-default --&gt;&lt;validators&gt; &lt;validator name="required" class="com.opensymphony.xwork2.validator.validators.RequiredFieldValidator"/&gt; &lt;validator name="requiredstring" class="com.opensymphony.xwork2.validator.validators.RequiredStringValidator"/&gt; &lt;validator name="int" class="com.opensymphony.xwork2.validator.validators.IntRangeFieldValidator"/&gt; &lt;validator name="long" class="com.opensymphony.xwork2.validator.validators.LongRangeFieldValidator"/&gt; &lt;validator name="short" class="com.opensymphony.xwork2.validator.validators.ShortRangeFieldValidator"/&gt; &lt;validator name="double" class="com.opensymphony.xwork2.validator.validators.DoubleRangeFieldValidator"/&gt; &lt;validator name="date" class="com.opensymphony.xwork2.validator.validators.DateRangeFieldValidator"/&gt; &lt;validator name="expression" class="com.opensymphony.xwork2.validator.validators.ExpressionValidator"/&gt; &lt;validator name="fieldexpression" class="com.opensymphony.xwork2.validator.validators.FieldExpressionValidator"/&gt; &lt;validator name="email" class="com.opensymphony.xwork2.validator.validators.EmailValidator"/&gt; &lt;validator name="url" class="com.opensymphony.xwork2.validator.validators.URLValidator"/&gt; &lt;validator name="visitor" class="com.opensymphony.xwork2.validator.validators.VisitorFieldValidator"/&gt; &lt;validator name="conversion" class="com.opensymphony.xwork2.validator.validators.ConversionErrorFieldValidator"/&gt; &lt;validator name="stringlength" class="com.opensymphony.xwork2.validator.validators.StringLengthFieldValidator"/&gt; &lt;validator name="regex" class="com.opensymphony.xwork2.validator.validators.RegexFieldValidator"/&gt; &lt;validator name="conditionalvisitor" class="com.opensymphony.xwork2.validator.validators.ConditionalVisitorFieldValidator"/&gt;&lt;/validators&gt;&emsp;&emsp;上面文件中每个&lt;validator&gt;元素都是一个校验规则，校验规则对应一些已经写好的方法，他们有校验属性非空的规则，有校验字符串属性长度的规则，有校验int属性范围的规则等等。通常我们不需要自己来编写校验规范，因为上面的校验规则已经足够了。&emsp;&emsp;每个规则都有自己的名字，校验文件中&lt;field-validator&gt;的type就是用来指定校验规则的名称。例如下面的代码是对username属性的非空校验：12345678910111213&lt;validators&gt; &lt;field name="username"&gt; &lt;field-validator type="requiredString"&gt; &lt;message&gt;用户名不能为空&lt;/message&gt; …… &lt;/field-validator&gt; &lt;/field&gt; ....&lt;/validators&gt;////解释如下////其中type=”requiredString”是校验规则的名称，它必须对应defualt.xml文件中&lt;validator&gt;元素的name属性值。requiredString校验规则是校验字符串属性是否长度为0，如果长度为0，它会向fieldError中添加错误信息,&lt;message&gt;元素指定的是错误信息。常用的校验规则123456789101112131415161718192021 required：当属性为null时校验失败； requiredstring：当字符串属性长度为0时校验失败： 参数trim：默认值为true，表示去除前后空白后再校验长度。 stringlength：当字符串长度不在指定范围内时校验失败：  minLength：指定字符串的最小长度；  maxLength：指定字符串的最大长度。 regex：属性不能匹配正则表达式时校验失败：  expression：指定正则表达式；  caseSensitive：默认值为true，表示不忽略大小写。 int：当int属性不在指定范围内校验失败：  min：最小值；  max：最大值。 double：当double属性不在指定范围内校验失败：  min：最小值；  max：最大值。 fieldexpression：属性必须是OGNL表达式：  expression：用来校验的ONGL表达式，例如pass == repass，其中pass和repass是两个属性名称， 当这两个属性的值相等时校验通过，否则失败。 email：属性必须是合法的邮件地址； url：属性必须是合法的网址； date：属性必须是合法的日期格式。校验进阶跳过指定的校验方法&emsp;&emsp;如果想跳过某个Action方法的校验,在不需要校验的Action方法上加入@SkipValidation&emsp;&emsp;我们都知道，一个Action中可以存在多个请求处理方法，不同的请求处理方法应该有不同的校验逻辑，所以我们应该为每个请求处理方法提供自己独有的校验方法。而validate()方法是所有请求处理方法公共的校验方法。指定校验某个方法public的，没有返回值，没有参数（public void xxx()）；方法名称前缀为validate（public void validateXxx()）；方法名后缀必须与请求处理方法名相同，例如请求处理方法为login()，那么它的私有校验方法为：public validateLogin()。注意，私有校验方法会在公共校验方法（validate()）之前被调用。如果你要为execute()提供私有校验方法，那么这个方法名为validateExecute()。12345678910111213141516171819public class Demo2Action extends ActionSupport &#123; public void validateLogin() &#123; System.out.println("validateLogin()..."); &#125; public void validateRegist() &#123; System.out.println("validateRegist()..."); &#125; public void validate() &#123; System.out.println("validate()..."); &#125; public String login() &#123; System.out.println("login()"); return NONE; &#125; public String regist() &#123; System.out.println("regist()"); return NONE; &#125;&#125;拦截器&emsp;&emsp;struts提供拦截器，对action类进行增强的。struts已经实现多个拦截器，完成不同的功能。例如：文件上传、数据校验、类型转换、参数封装等默认拦截器栈&emsp;&emsp;struts-default.xml提供struts所有拦截器，也提供默认拦截器栈&lt;default-interceptor-ref name=&quot;defaultStack&quot;/&gt; 所有的action默认使用那个拦截器栈&lt;interceptor-stack name=&quot;defaultStack&quot;&gt;声明一个拦截器栈，名称为“defaultStack”，通常称为：默认拦截器栈1234567891011121314151617181920212223242526272829303132333435363738394041&lt;interceptor-stack name="defaultStack"&gt; &lt;interceptor-ref name="exception"/&gt; &lt;interceptor-ref name="alias"/&gt; &lt;interceptor-ref name="servletConfig"/&gt; &lt;!-- 用于给action类注入Servlet api。 例如：action类实现ServletRequestAware就可以被struts框架注入HttpServletRequest对象 --&gt; &lt;interceptor-ref name="i18n"/&gt; &lt;interceptor-ref name="prepare"/&gt; &lt;interceptor-ref name="chain"/&gt; &lt;interceptor-ref name="scopedModelDriven"/&gt; &lt;interceptor-ref name="modelDriven"/&gt; &lt;!-- 调用action类的getModel()方法，获得javabean实例，如果没为null，将交予struts。 --&gt; &lt;interceptor-ref name="fileUpload"/&gt; &lt;!-- struts默认支持文件上传 --&gt; &lt;interceptor-ref name="checkbox"/&gt; &lt;interceptor-ref name="multiselect"/&gt; &lt;interceptor-ref name="staticParams"/&gt; &lt;interceptor-ref name="actionMappingParams"/&gt; &lt;interceptor-ref name="params"&gt; &lt;!-- 给action类进行数据封装。如果使用ModelDriven，就给javabean封装数据 --&gt; &lt;param name="excludeParams"&gt;dojo\..*,^struts\..*,^session\..*,^request\..*,^application\..*,^servlet(Request|Response)\..*,parameters\...*&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="conversionError"/&gt; &lt;!-- 将转换错误添加到action类的错误提示信息中。 将执行 action.addFieldError("属性","错误提示"); --&gt; &lt;interceptor-ref name="validation"&gt; &lt;!-- 将执行action所有校验。先执行注解校验，再执行单个方法校验，最后所有方法的校验 --&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="workflow"&gt; &lt;!-- 从action类获得添加的错误信息，如果没有发行。如果有返回“input” 方式1：默认情况，如果存在错误，返回值“input” 方式2：实现接口ValidationWorkflowAware，修改整个action的错误返回结果集名称，将执行方法 getInputResultName() 方式3：通过@InputConfig注解，给指定的方法配置出现错误时，返回结果result的名称。 --&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="debugging"/&gt;&lt;/interceptor-stack&gt;关于workflow拦截器的补充：123456789101112131415161718//方法2：实现ValidationWorkflowAware接口public class Demo8Action extends ActionSupport implements ValidationWorkflowAware&#123; @Override public String getInputResultName()&#123; return "xxx";//出现错误不再返回input,而是xxx,所有的方法都使用 &#125;&#125;//方法3：通过@InputConfig注解 @InputConfig(resultName="loginInput") //如果登录出现异常，将返回不是input，而是loginInput public String login()&#123; return SUCCESS; &#125; @InputConfig(resultName="registerInput") //如果注册出现异常，将返回不是input，而是registerInput public String register()&#123; return SUCCESS; &#125;自定义拦截器实现接口：com.opensymphony.xwork2.interceptor.Interceptor123456789//初始化方法public void init() &#123; &#125;//拦截方法public abstract String intercept(ActionInvocation invocation) throws Exception&#123; invocation.getAction() 获得当前action类实例 invacation.invoke() 放行&#125;//销毁方法public void destroy() &#123; &#125;继承父类：com.opensymphony.xwork2.interceptor.MethodFilterInterceptor在使用自定义拦截器，可以对指定的方法进行操作（哪些方法不拦截，哪些必须拦截）设置属性includeMethods，确定哪些方法进行拦截设置属性excludeMethods，确定哪些方法不进行拦截&lt;default-interceptor-ref name=&quot;xxx&quot;&gt;将指定的拦截器，声明成默认的。注意：如果使用自定义xxx，“defaultStack”将被覆盖。注意：拦截器只拦截action类，不拦截jsp文件。使用拦截器进行表单参数校验校验流程:&emsp;&emsp;Validation拦截器负责判断Action是否实现Validateable接口.如果实现就调用validate方法.&emsp;&emsp;workflow拦截器判断Action是否实现ValidationAware接口. 如果实现就会判断Action中是否包含错误信息.如果包含错误信息, 停止拦截器递归调用,返回结果到名为input的结果页面中.编程式校验&emsp;&emsp;实现Validateable接口.接口中只有一个方法validate方法.我们可以在该方法中添加错误信息.&emsp;&emsp;添加错误信息需要实现ValidationAware接口.该接口中有一些判断是否含有错误消息.获得错误消息.添加错误消息的方法.拦截器的注册&emsp;&emsp;注册拦截器一共分为两步：在package中声明拦截器在action中引用拦截器1234567891011121314151617181920212223242526&lt;package name="s8" namespace="/" extends="struts-default"&gt; &lt;interceptors&gt; &lt;!-- 在&lt;aciton&gt;元素中引用拦截器的顺序决定了拦截器的执行顺序， 例中会先执行defaultStack中的所有拦截器，再执行MyInterceptor拦截器 --&gt; &lt;interceptor name="MyInterceptor" class="cn.itcast.interceptor.MyInterceptor" /&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="defaultStack" /&gt; &lt;!-- struts2中，一旦为Action指定了拦截器，那么就不会再为这个Action执行默认拦截器了 以我们需要在这个&lt;action&gt;元素中再引用defaultStack拦截器栈。 --&gt; &lt;interceptor-ref name="MyInterceptor" /&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;default-interceptor-ref name="myStack" /&gt; &lt;action name="LoginAction"&gt; &lt;result&gt;/index.jsp&lt;/result&gt; &lt;result name="input"&gt;/login.jsp&lt;/result&gt; &lt;!--若没有将创建的拦截器指定为默认拦截器，需要加入以下语句： &lt;interceptor-ref name="defaultStack" /&gt; &lt;interceptor-ref name="MyInterceptor" /&gt; --&gt; &lt;/action&gt;&lt;/package&gt;OGNL与struts标签未完待续]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Struts2，ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hinernate学习笔记]]></title>
    <url>%2F2018%2F07%2F23%2FHinernate%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[hibernateHibernate初印象ssh执行的基本流程hibernate执行的基本流程准备文件&emsp;download from hibernate.org:&emsp;&emsp; hibernate-annotation-3.4.0.GA.zip&emsp;&emsp; hibernate-distrubution-3.3.2.GA-dist.zip&emsp;&emsp; slf4j-1.5.8.zip暂停，先学mybatis]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>ssh框架学习 hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown学习与文档]]></title>
    <url>%2F2018%2F07%2F22%2Fartical-title%2F</url>
    <content type="text"><![CDATA[第一篇markdown文档markdown语法标题标题1标题2区块引用1区块引用2区块引用3无序列表123123有序列表12212分割线代码块* //两个tap代码块/8个空格+字符 int i = 0; int j =i; * 行内链接行内参考式1行内参考式2强调1强调2强调3句内代码 aa块Use the printf() function.http://www.baidu.com普通连接转义符*>表格列1（右对齐）列2（居中）列3（左对齐）ABCDEF]]></content>
      <categories>
        <category>TestDoc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
  </entry>
</search>
